---
title: مدیریت دستوری اشیاء Kubernetes با استفاده از فایل‌های پیکربندی
content_type: task
weight: 40
---

<!-- overview -->
اشیاء Kubernetes می‌توانند با استفاده از ابزار خط فرمان `kubectl` و یک فایل پیکربندی شیء نوشته شده به صورت YAML یا JSON ایجاد، به‌روزرسانی و حذف شوند. این سند توضیح می‌دهد که چگونه اشیاء را با استفاده از فایل‌های پیکربندی تعریف و مدیریت کنیم.

## {{% heading "prerequisites" %}}

نصب [`kubectl`](/docs/tasks/tools/).

{{< include "task-tutorial-prereqs.md" >}} {{< version-check >}}

<!-- steps -->

## مزایا و معایب

ابزار `kubectl` از سه نوع مدیریت اشیاء پشتیبانی می‌کند:

* دستورات دستوری
* پیکربندی شیء دستوری
* پیکربندی شیء اعلامی

برای بحث در مورد مزایا و معایب هر نوع مدیریت شیء، به [مدیریت اشیاء Kubernetes](/docs/concepts/overview/working-with-objects/object-management/) مراجعه کنید.

## نحوه ایجاد اشیاء

می‌توانید از `kubectl create -f` برای ایجاد یک شیء از یک فایل پیکربندی استفاده کنید.
برای جزئیات به [مرجع API Kubernetes](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/) مراجعه کنید.

* `kubectl create -f <filename|url>`

## نحوه به‌روزرسانی اشیاء

{{< warning >}}
به‌روزرسانی اشیاء با دستور `replace` تمام قسمت‌های مشخصات که در فایل پیکربندی مشخص نشده‌اند را حذف می‌کند. این نباید برای اشیائی که مشخصات آنها به صورت جزئی توسط خوشه مدیریت می‌شود استفاده شود، مانند Services از نوع `LoadBalancer` که در آن فیلد `externalIPs` به صورت مستقل از فایل پیکربندی مدیریت می‌شود. فیلدهایی که به صورت مستقل مدیریت می‌شوند باید به فایل پیکربندی کپی شوند تا `replace` آنها را حذف نکند.
{{< /warning >}}

می‌توانید از `kubectl replace -f` برای به‌روزرسانی یک شیء زنده بر اساس یک فایل پیکربندی استفاده کنید.

* `kubectl replace -f <filename|url>`

## نحوه حذف اشیاء

می‌توانید از `kubectl delete -f` برای حذف یک شیء که در یک فایل پیکربندی توصیف شده است استفاده کنید.

* `kubectl delete -f <filename|url>`

{{< note >}}
اگر فایل پیکربندی فیلد `generateName` را در بخش `metadata` به جای فیلد `name` مشخص کرده باشد، نمی‌توانید شیء را با استفاده از `kubectl delete -f <filename|url>` حذف کنید.
باید از پرچم‌های دیگر برای حذف شیء استفاده کنید. برای مثال:

```shell
kubectl delete <type> <name>
kubectl delete <type> -l <label>
```
{{< /note >}}

## نحوه مشاهده یک شیء

می‌توانید از `kubectl get -f` برای مشاهده اطلاعات درباره یک شیء که در یک فایل پیکربندی توصیف شده است استفاده کنید.

* `kubectl get -f <filename|url> -o yaml`

پرچم `-o yaml` مشخص می‌کند که پیکربندی کامل شیء چاپ شود.
برای دیدن لیستی از گزینه‌ها از `kubectl get -h` استفاده کنید.

## محدودیت‌ها

دستورات `create`، `replace` و `delete` هنگامی که پیکربندی هر شیء به صورت کامل تعریف و در فایل پیکربندی آن ضبط شده باشد به خوبی کار می‌کنند. اما هنگامی که یک شیء زنده به‌روزرسانی می‌شود و این به‌روزرسانی‌ها به فایل پیکربندی آن ادغام نمی‌شوند، به‌روزرسانی‌ها در دفعه بعدی که `replace` اجرا شود از دست خواهند رفت. این اتفاق می‌تواند زمانی رخ دهد که یک کنترلر، مانند HorizontalPodAutoscaler، به‌روزرسانی‌هایی را به صورت مستقیم به یک شیء زنده اعمال کند. در اینجا مثالی آورده شده است:

1. یک شیء را از یک فایل پیکربندی ایجاد می‌کنید.
1. منبع دیگری شیء را با تغییر دادن برخی از فیلدها به‌روزرسانی می‌کند.
1. شیء را از فایل پیکربندی جایگزین می‌کنید. تغییراتی که توسط منبع دیگر در مرحله 2 ایجاد شده بودند از بین می‌روند.

اگر نیاز به پشتیبانی از نویسندگان متعدد برای همان شیء دارید، می‌توانید از `kubectl apply` برای مدیریت شیء استفاده کنید.

## ایجاد و ویرایش یک شیء از یک URL بدون ذخیره پیکربندی

فرض کنید URL یک فایل پیکربندی شیء را دارید. می‌توانید از `kubectl create --edit` برای ایجاد تغییرات در پیکربندی قبل از ایجاد شیء استفاده کنید. این به ویژه برای آموزش‌ها و وظایفی که به یک فایل پیکربندی اشاره می‌کنند که توسط خواننده قابل تغییر است مفید است.

```shell
kubectl create -f <url> --edit
```

## مهاجرت از دستورات دستوری به پیکربندی شیء دستوری

مهاجرت از دستورات دستوری به پیکربندی شیء دستوری شامل چندین مرحله دستی است.

1. شیء زنده را به یک فایل پیکربندی شیء محلی صادر کنید:

    ```shell
    kubectl get <kind>/<name> -o yaml > <kind>_<name>.yaml
    ```

1. فیلد status را به صورت دستی از فایل پیکربندی شیء حذف کنید.

1. برای مدیریت‌های بعدی شیء، از `replace` به صورت انحصاری استفاده کنید.

    ```shell
    kubectl replace -f <kind>_<name>.yaml
    ```

## تعریف selector کنترلرها و برچسب‌های PodTemplate

{{< warning >}}
به‌روزرسانی selectors بر روی کنترلرها به شدت توصیه نمی‌شود.
{{< /warning >}}

رویکرد پیشنهادی این است که یک برچسب PodTemplate ثابت تعریف کنید که فقط توسط selector کنترلر استفاده می‌شود و معنای معنایی دیگری ندارد.

مثال برچسب:

```yaml
selector:
  matchLabels:
      controller-selector: "apps/v1/deployment/nginx"
template:
  metadata:
    labels:
      controller-selector: "apps/v1/deployment/nginx"
```

## {{% heading "whatsnext" %}}

* [مدیریت دستوری اشیاء Kubernetes با استفاده از دستورات دستوری](/docs/tasks/manage-kubernetes-objects/imperative-command/)
* [مدیریت اعلامی اشیاء Kubernetes با استفاده از فایل‌های پیکربندی](/docs/tasks/manage-kubernetes-objects/declarative-config/)
* [مرجع دستورات Kubectl](/docs/reference/generated/kubectl/kubectl-commands/)
* [مرجع API Kubernetes](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/)