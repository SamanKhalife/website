---
title: گسترش kubectl با پلاگین‌ها
reviewers:
- juanvallejo
- soltysh
description: گسترش kubectl با ایجاد و نصب پلاگین‌های kubectl.
content_type: task
---

<!-- overview -->

این راهنما نحوه نصب و نوشتن افزونه‌ها برای [kubectl](/docs/reference/kubectl/kubectl/) را نشان می‌دهد. با در نظر گرفتن دستورات اصلی `kubectl` به عنوان انشعابات اساسی برای تعامل با یک خوشه Kubernetes، یک مدیر خوشه می‌تواند با استفاده از پلاگین‌ها، این انشعابات را به عنوان وسیله‌ای برای ایجاد رفتارهای پیچیده‌تر استفاده کند. پلاگین‌ها `kubectl` را با زیردستورهای جدید گسترش می‌دهند که امکان استفاده از ویژگی‌های جدید و سفارشی که در توزیع اصلی `kubectl` موجود نیستند را فراهم می‌کنند.

## {{% heading "پیش‌نیازها" %}}

شما باید یک باینری کاربری `kubectl` نصب شده داشته باشید.

<!-- steps -->

## نصب پلاگین‌های kubectl

یک پلاگین یک فایل اجرایی مستقل است که با `kubectl-` شروع می‌شود. برای نصب یک پلاگین، فایل اجرایی آن را به هر مکانی در `PATH` خود منتقل کنید.

همچنین می‌توانید پلاگین‌های kubectl موجود در منبع باز را با استفاده از [Krew](https://krew.dev/) کشف و نصب کنید. Krew یک مدیر پلاگین است که توسط جامعه Kubernetes SIG CLI حفظ می‌شود.

{{< caution >}}
پلاگین‌های `kubectl` موجود از طریق فهرست پلاگین [Krew](https://krew.sigs.k8s.io/plugins/) برای امنیت بازبینی نشده‌اند. شما باید پلاگین‌های شخص ثالث را به خطر خود اجرا کنید، زیرا این برنامه‌های تصادفی در دستگاه شما اجرا می‌شوند.
{{< /caution >}}

### کشف پلاگین‌ها

`kubectl` دستور `kubectl plugin list` را فراهم می‌کند که مسیر `PATH` شما را برای اجرایی‌های پلاگین معتبر جستجو می‌کند. اجرای این دستور باعث می‌شود که تراورس تمام فایل‌ها در `PATH` شما صورت گیرد. هر فایل قابل اجرا که با `kubectl-` شروع شود، در این دستور خروجی *با ترتیبی که در `PATH` شما حضور دارند* نشان داده می‌شود. همچنین یک هشدار برای هر فایلی که با `kubectl-` شروع شود و *قابل اجرا نیست* به خروجی اضافه می‌شود. همچنین یک هشدار برای هر فایل پلاگین معتبری که نام‌های آن به هم چسبیده باشد.

شما می‌توانید از [Krew](https://krew.dev/) برای کشف و نصب پلاگین‌های `kubectl` از یک [فهرست پلاگین](https://krew.sigs.k8s.io/plugins/) تأیید شده توسط جامعه استفاده کنید.

#### محدودیت‌ها

در حال حاضر امکان ایجاد پلاگین‌هایی که دستورات موجود `kubectl` را بازنویسی می‌کنند وجود ندارد. به عنوان مثال، ایجاد یک پلاگین `kubectl-version` باعث می‌شود که آن پلاگین هرگز اجرا نشود، زیرا دستور موجود `kubectl version` همیشه به اولویت اول خواهد رسید. به دلیل این محدودیت، همچنین *امکان ندارد* که از طریق پلاگین‌ها زیردستورهای جدید به دستورات موجود `kubectl` اضافه کنید. به عنوان مثال، اضافه کردن زیردستور `kubectl create foo` با نام پلاگین `kubectl-create-foo` باعث نادیده گرفته شدن آن پلاگین خواهد شد.

`kubectl plugin list` برای هر پلاگین معتبری که تلاش می‌کند این کار را انجام دهد، هشدارها را نشان می‌دهد.

## نوشتن پلاگین‌های kubectl

می‌توانید یک پلاگین را در هر زبان برنامه‌نویسی یا اسکریپتی که به شما اجازه اجرای دستورات خط فرمان را می‌دهد، بنویسید.

هیچ نصب یا پیش‌بارگذاری پلاگین لازم نیست. فایل‌های اجرایی پلاگین‌ها محیط به ارث برده شده از باینری `kubectl` را دریافت می‌کنند.
یک پلاگین تعیین می‌کند که کدام مسیر دستور را می‌خواهد بر اساس نام آن اجرا کند.
به عنوان مثال، یک پلاگین با نام `kubectl-foo` یک دستور `kubectl foo` ارائه می‌دهد. شما باید فایل اجرایی پلاگین را در هر جایی از `PATH` خود نصب کنید.

### مثال پلاگین

```bash
#!/bin/bash

# optional argument handling
if [[ "$1" == "version" ]]
then
    echo "1.0.0"
    exit 0
fi

# optional argument handling
if [[ "$1" == "config" ]]
then
    echo "$KUBECONFIG"
    exit 0
fi

echo "I am a plugin named kubectl-foo"
```
```markdown
### استفاده از پلاگین

برای استفاده از پلاگین، پلاگین را قابل اجرا کنید:

```shell
sudo chmod +x ./kubectl-foo
```

و آن را در هر مکانی در `PATH` خود قرار دهید:

```shell
sudo mv ./kubectl-foo /usr/local/bin
```

حالا می‌توانید پلاگین خود را به عنوان یک دستور `kubectl` فراخوانی کنید:

```shell
kubectl foo
```

```
I am a plugin named kubectl-foo
```

همه آرگومان‌ها و پرچم‌ها به صورت دقیق به فایل اجرایی منتقل می‌شوند:

```shell
kubectl foo version
```

```
1.0.0
```

همه متغیرهای محیطی نیز به صورت دقیق به فایل اجرایی منتقل می‌شوند:

```bash
export KUBECONFIG=~/.kube/config
kubectl foo config
```

```
/home/<user>/.kube/config
```

```shell
KUBECONFIG=/etc/kube/config kubectl foo config
```

```
/etc/kube/config
```

به علاوه، اولین آرگومانی که به یک پلاگین منتقل می‌شود همیشه مسیر کامل به مکانی است که فراخوانی شد (`$0` معادل `/usr/local/bin/kubectl-foo` در مثال بالا).

### نام‌گذاری پلاگین

همانطور که در مثال بالا مشاهده می‌کنید، یک پلاگین مسیر دستوری که می‌خواهد بر اساس نام فایل خود پیاده سازی کند را تعیین می‌کند. هر زیردستور در مسیر دستوری که یک پلاگین به آن هدف گردش است، با خط تیره (`-`) جدا شده است.
به عنوان مثال، یک پلاگین که می‌خواهد هر زمان که کاربر دستور `kubectl foo bar baz` را فراخوانی می‌کند، فایل نام `kubectl-foo-bar-baz` را داشته باشد.

#### پرچم‌ها و مدیریت آرگومان‌ها

{{< note >}}
مکانیزم پلاگین هیچ مقادیر سفارشی و محیطی مخصوص پلاگین برای یک فرآیند پلاگین ایجاد نمی‌کند.
یک مکانیزم پلاگین قدیمی‌تر `kubectl` متغیرهای محیطی مانند `KUBECTL_PLUGINS_CURRENT_NAMESPACE` را ارائه می‌دهد؛ این امر دیگر اتفاق نمی‌افتد.
{{< /note >}}

پلاگین‌های `kubectl` باید همه آرگومان‌های منتقل شده به آن‌ها را تجزیه و اعتبارسنجی کنند.
برای جزئیات درباره کتابخانه Go که به نویسندگان پلاگین هدفمند شده است، به [استفاده از بسته runtime بسته فرمان خط](#استفاده-از-بسته-فرمان-خط) مراجعه کنید.

در زیر، موارد دیگری آورده شده‌اند که کاربران هنگام فراخوانی پلاگین‌های شما وقتی که پرچم‌ها و آرگومان‌های اضافی ارائه می‌دهند، مشهود می‌شود. این موضوع بر روی پلاگین `kubectl-foo-bar-baz` از سناریو بالا ساخته شده است.

اگر شما دستور `kubectl foo bar baz arg1 --flag=value arg2` را اجرا کنید، مکانیزم پلاگین `kubectl` ابتدا تلاش می‌کند تا پلاگین با بیشترین نام ممکن را پیدا کند که در این مورد
ممکن است `kubectl-foo-bar-baz-arg1` باشد. هنگامی که پلاگین مورد نظر را پیدا نکرد، `kubectl` آن دیگر را به عنوان آخرین مقدار جدا شده با خط تیره (`-`) به عنوان آرگومان (`arg1` در این مورد) در نظر می‌گیرد، و سعی می‌کند که نام بیشترین نام ممکن را پیدا کند، `kubectl-foo-bar-baz`.
پس از پیدا کردن یک پلاگین با این نام، `kubectl` آن پلاگین را فراخوانی می‌کند و تمام آرگومان‌ها و پرچم‌های پس از نام پلاگین به عنوان آرگومان به فرآیند پلاگین منتقل می‌کند.

مثال:

```bash
# ایجاد یک پلاگین
echo -e '#!/bin/bash\n\necho "My first command-line argument was $1"' > kubectl-foo-bar-baz
sudo chmod +x ./kubectl-foo-bar-baz

# "نصب" پلاگین خود را با جابجایی آن به یک دایرکتوری در $PATH خود
sudo mv ./kubectl-foo-bar-baz /usr/local/bin

# بررسی اینکه kubectl پلاگین شما را شناسایی می‌کند
kubectl plugin list
```

```
The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-foo-bar-baz
```

```
# تست کنید که فراخوانی پلاگین خود را از طریق یک دستور "kubectl" کار می‌کند
# حتی زمانی که آرگومان‌ها و پرچم‌های اضافی به اجرایی پلاگین توسط کاربر منتقل می‌شوند.
kubectl foo bar baz arg1 --meaningless-flag=true
```

```
My first command-line argument was arg1
```

همانطور که می‌بینید، پلاگین شما بر اساس دستور `kubectl` که توسط کاربر مشخص شده است، پیدا شد و تمام آرگومان‌ها و پرچم‌های اضافی به عنوان آرگومان‌های فرآیند پلاگین به عنوان آن به منتقل شد.

#### نام‌ها با خط‌ها و زیرزمینه‌ها

اگرچه مکانیزم پلاگین `kubectl` از خط (`-`) در نام فایل‌های پلاگین برای جدا

 کردن دنباله دستورهای زیرزمینه‌های پردازش شده توسط پلاگین استفاده می‌کند، باز هم امکان دارد تا پلاگینی
دستور حاوی خطوط را در فراخوانی اجرا کند با استفاده از زیر زمینه‌ها (`_`) در نام فایل خود.

مثال:

```bash
# ایجاد یک پلاگین حاوی یک زیر زمینه در نام فایل خود
echo -e '#!/bin/bash\n\necho "I am a plugin with a dash in my name"' > ./kubectl-foo_bar
sudo chmod +x ./kubectl-foo_bar

# جابجایی پلاگین در $PATH خود
sudo mv ./kubectl-foo_bar /usr/local/bin

# شما می‌توانید اکنون پلاگین خود را از طریق kubectl فراخوانی کنید:
kubectl foo-bar
```

```
I am a plugin with a dash in my name
```

توجه داشته باشید که معرفی خط‌ها به نام فایل پلاگین از شما جلوگیری نمی‌کند که دستوراتی مانند `kubectl foo_bar` را داشته باشید.
فرمان از مثال بالا، می‌توانید آن را با استفاده از خط (`-`) یا زیر زمینه (`_`) فراخوانی کنید:

```bash
# می‌توانید دستور سفارشی خود را با خط فرمان
kubectl foo-bar
```

```
I am a plugin with a dash in my name
```

```bash
# همچنین می‌توانید دستور سفارشی خود را با استفاده از یک زیرزمینه فراخوانی کنید
kubectl foo_bar
```

```
I am a plugin with a dash in my name
```

#### تداخل نام و سایه‌اندازی

امکان دارد که چندین پلاگین با همان نام فایل در مکان‌های مختلف موجود در `PATH` شما وجود داشته باشد. به عنوان مثال، در صورتی که مقدار `PATH` شامل این مقادیر باشد: `PATH=/usr/local/bin/plugins:/usr/local/bin/moreplugins`، یک کپی از پلاگین `kubectl-foo` ممکن است در `/usr/local/bin/plugins` و `/usr/local/bin/moreplugins` وجود داشته باشد، به طوری که خروجی دستور `kubectl plugin list` به صورت زیر خواهد بود:

```bash
PATH=/usr/local/bin/plugins:/usr/local/bin/moreplugins kubectl plugin list
```

```
The following kubectl-compatible plugins are available:

/usr/local/bin/plugins/kubectl-foo
/usr/local/bin/moreplugins/kubectl-foo
  - warning: /usr/local/bin/moreplugins/kubectl-foo is overshadowed by a similarly named plugin: /usr/local/bin/plugins/kubectl-foo

error: one plugin warning was found
```

در سناریو فوق، هشدار زیر `/usr/local/bin/moreplugins/kubectl-foo` به شما می‌گوید که این پلاگین هرگز اجرا نخواهد شد. به جای آن، اجرای اولین فایل قرار گرفته در `PATH` شما، یعنی `/usr/local/bin/plugins/kubectl-foo`، همیشه توسط مکانیزم پلاگین `kubectl` پیدا و اجرا خواهد شد.

برای حل این مشکل، مطمئن شوید که مکان پلاگینی که می‌خواهید با `kubectl` استفاده کنید، همیشه اولین مورد در `PATH` شما باشد. به عنوان مثال، اگر می‌خواهید همیشه از `/usr/local/bin/moreplugins/kubectl-foo` استفاده کنید هنگامی که دستور `kubectl foo` فراخوانی می‌شود، مقدار `PATH` را به `/usr/local/bin/moreplugins:/usr/local/bin/plugins` تغییر دهید.

#### فراخوانی با نام فایل اجرایی بیشترین

یک نوع دیگر از سایه‌اندازی که ممکن است با نام فایل‌های پلاگین رخ دهد، فراخوانی با نام فایل اجرایی بیشترین است. با دو پلاگین حاضر در `PATH` کاربر: `kubectl-foo-bar` و `kubectl-foo-bar-baz`، مکانیزم پلاگین `kubectl` همیشه نام پلاگین بیشترین ممکن را برای یک دستور کاربر انتخاب خواهد کرد. تعدادی مثال زیر این موضوع را بهتر می‌رساند:

```bash
# برای یک دستور kubectl داده شده، پلاگین با نام فایل اجرایی بیشترین ممکن همیشه انتخاب می‌شود
kubectl foo bar baz
```

```
پلاگین kubectl-foo-bar-baz اجرا می‌شود
```

```bash
kubectl foo bar
```

```
پلاگین kubectl-foo-bar اجرا می‌شود
```

```bash
kubectl foo bar baz buz
```

```
پلاگین kubectl-foo-bar-baz اجرا می‌شود، با "buz" به عنوان اولین آرگومان آن
```

```bash
kubectl foo bar buz
```

```
پلاگین kubectl-foo-bar اجرا می‌شود، با "buz" به عنوان اولین آرگومان آن
```

این انتخاب طراحی اطمینان می‌دهد که زیر دستورهای پلاگین می‌توانند در اسناد چندین فایل پیاده سازی شوند، اگر نیاز باشد و این زیردستورها می‌توانند تحت یک دستور "والد" پلاگین جای گیری شوند:

```bash
ls ./plugin_command_tree
```

```
kubectl-parent
kubectl-parent-subcommand
kubectl-parent-subcommand-subsubcommand
```

### بررسی هشدارهای پلاگین

می‌توانید از دستور `kubectl plugin list` فوق استفاده کنید تا اطمینان حاصل کنید که پلاگین شما توسط `kubectl` قابل مشاهده است و بررسی کنید که هیچ هشداری از جلوگیری از آن به عنوان یک دستور `kubectl` وجود ندارد.

```bash
kubectl plugin list
```

```
The following kubectl-compatible plugins are available:

test/fixtures/pkg/kubectl/plugins/kubectl-foo
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo is overshadowed by a similarly named plugin: test/fixtures/pkg/kubectl/plugins/kubectl-foo
plugins/kubectl-invalid
  - warning: plugins/kubectl-invalid identified as a kubectl plugin, but it is not executable

error: 2 plugin warnings were found
```

### استفاده از بسته runtime خط فرمان

اگر شما یک پلاگین برای `kubectl` می‌نویسید و از زبان Go استفاده می‌کنید، می‌توانید از کتابخانه‌های ابزار مفید موجود در [cli-runtime](https://github.com/kubernetes/cli-runtime) استفاده کنید.

این کتابخانه‌ها کمک‌هایی برای تجزیه و بروزرسانی پرونده `kubeconfig` کاربر، برای انجام درخواست‌های نوع REST به سرور API، یا برای معرفی پرچم‌های مرتبط با پیکربندی و چاپ فراهم می‌کنند.

برای مثال، [پلاگین CLI نمونه](https://github.com/kubernetes/sample-cli-plugin) را برای یک نمونه استفاده از ابزارهای ارائه شده در مخزن CLI Runtime بخوانید.

## توزیع پلاگین‌های kubectl

اگر شما یک پلاگین توسعه داده‌اید که دیگران بتوانند از آن استفاده کنند، باید در نظر داشته باشید که چگونه آن را بسته‌بندی، توزیع و به روز رسانی برای کاربران خود ارائه دهید.

### Krew {#distributing-krew}

[Krew](https://krew.dev/) روشی چندپلتفرمه برای بسته‌بندی و توزیع پلاگین‌های شما ارائه می‌دهد. با است

فاده از این روش، شما یک فرمت بسته‌بندی یکسان برای همه پلتفرم‌های هدف (لینوکس، ویندوز، macOS و غیره) استفاده می‌کنید و به کاربران خود به روز رسانی ارائه می‌دهید. Krew همچنین یک [فهرست پلاگین](https://krew.sigs.k8s.io/plugins/) را حفظ می‌کند تا دیگر افراد بتوانند پلاگین شما را کشف و نصب کنند.

### مدیریت بسته نیتیو / وابسته به پلتفرم {#distributing-native}

به عنوان جایگزین، می‌توانید از مدیران بسته سنتی مانند `apt` یا `yum` در لینوکس، Chocolatey در ویندوز، و Homebrew در macOS استفاده کنید. هر مدیر بسته‌ای مناسب خواهد بود که بتواند اجرایی‌های جدید را در مکان‌هایی که مسیر کاربران است قرار دهد. به عنوان یک نویسنده پلاگین، اگر این گزینه را انتخاب کنید، شما همچنین باید به روز رسانی بسته توزیع پلاگین kubectl خود را برای هر نسخه منتشر شده در چندین پلتفرم را انجام دهید.

### کد منبع {#distributing-source-code}

می‌توانید کد منبع را منتشر کنید؛ به عنوان مثال، به عنوان یک مخزن Git. اگر این گزینه را انتخاب کنید، شخصی که می‌خواهد از آن پلاگین استفاده کند باید کد را فراخوانی کند، محیط ساخت را تنظیم کند (اگر نیاز به کامپایل دارد) و پلاگین را پیاده‌سازی کند. اگر همچنین بسته‌های کامپایل شده را در دسترس قرار دهید یا از Krew استفاده کنید، این کار نصب را آسان‌تر می‌کند.
