---
title: حساب‌های خدماتی
description: >
  در اینجا با اشیاء ServiceAccount در Kubernetes آشنا می‌شوید.
api_metadata:
- apiVersion: "v1"
  kind: "ServiceAccount"  
content_type: concept
weight: 25
---

<!-- مرور -->

این صفحه به معرفی اشیاء ServiceAccount در Kubernetes می‌پردازد، اطلاعاتی درباره‌ی نحوه عملکرد حساب‌های خدماتی، موارد استفاده، محدودیت‌ها، جایگزینی‌ها، و پیوندهایی به منابع برای راهنمایی‌های اضافی ارائه می‌دهد.

<!-- بدنه -->

## حساب‌های خدماتی چیستند؟ {#what-are-service-accounts}

حساب‌های خدماتی نوعی از حساب‌های غیرانسانی هستند که در Kubernetes، هویت متمایزی را در یک کلاستر Kubernetes فراهم می‌کنند. پاد‌های برنامه، اجزا سیستمی، و موجودیت‌های داخلی و خارجی می‌توانند با استفاده از اعتبارات یک ServiceAccount خاص به عنوان آن ServiceAccount شناخته شوند. این هویت در موارد مختلفی مانند احراز هویت در برابر سرور API یا پیاده‌سازی سیاست‌های امنیتی مبتنی بر هویت، مفید است.

حساب‌های خدماتی به عنوان اشیاء ServiceAccount در سرور API وجود دارند. حساب‌های خدماتی دارای ویژگی‌های زیر هستند:

* **Namespaced:** هر حساب خدماتی به یک {{<glossary_tooltip text="فضای نام" term_id="namespace">}} Kubernetes مرتبط می‌شود. هر فضای نام به صورت پیش‌فرض یک [`default` ServiceAccount](#default-service-accounts) دارد.
  
* **سبک:** حساب‌های خدماتی در کلاستر وجود دارند و در سرور API Kubernetes تعریف می‌شوند. شما می‌توانید به سرعت حساب‌های خدماتی را ایجاد کنید تا وظایف خاصی را فعال کنید.

* **قابل حمل:** یک بسته پیکربندی برای یک بارگیری کارکرد بارگیری‌شده پیچیده ممکن است شامل تعریفات حساب‌های خدماتی برای اجزای سیستم باشد. طبیعت سبک حساب‌های خدماتی و هویت‌های namespace شده، پیکربندی‌ها را قابل حمل می‌کند.

حساب‌های خدماتی با حساب‌های کاربری متفاوت هستند که کاربران انسانی تأیید شده در کلاستر هستند. به طور پیش‌فرض، حساب‌های کاربری در سرور API Kubernetes وجود ندارند؛ به جای اینکه سرور API، هویت کاربران را به عنوان داده‌های اپاک در نظر می‌گیرد. شما می‌توانید با استفاده از چندین روش به عنوان یک حساب کاربری احراز هویت کنید. برخی توزیع‌های Kubernetes ممکن است API‌های توسعه‌داده شده سفارشی را برای نمایش حساب‌های کاربری در سرور API اضافه کنند.

{{< table caption="مقایسه بین حساب‌های خدماتی و کاربر یا گروه" >}}

| توضیحات | ServiceAccount | کاربر یا گروه |
| --- | --- | --- |
| مکان | Kubernetes API (شیء ServiceAccount) | خارجی |
| کنترل دسترسی | Kubernetes RBAC یا سایر [مکانیزم‌های اجازه‌دهی](/docs/reference/access-authn-authz/authorization/#authorization-modules) | Kubernetes RBAC یا سایر مکانیزم‌های مدیریت هویت و دسترسی |
| استفاده مقصود | بارگیری‌ها، خودکارسازی | افراد |

{{< /table >}}

### حساب‌های خدماتی پیش‌فرض {#default-service-accounts}

زمانی که یک کلاستر ایجاد می‌کنید، Kubernetes به طور خودکار یک شیء ServiceAccount با نام `default` برای هر فضای نام در کلاستر شما ایجاد می‌کند. حساب‌های خدماتی `default` در هر فضای نام به طور پیش‌فرض هیچ مجوزی ندارند به جز [مجوزهای پیش‌فرض کشف API](/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings) که Kubernetes آن‌ها را به تمام اصول احراز هویت شده اعطا می‌کند اگر کنترل دسترسی بر اساس نقش (RBAC) فعال باشد. اگر شیء ServiceAccount `default` را در یک فضای نام حذف کنید، {{< glossary_tooltip text="control plane" term_id="control-plane" >}} آن را با یک شیء جدید جایگزین می‌کند.

اگر یک Pod را در یک فضای نام رها کنید و به Pod [ServiceAccount را به صورت دستی اختصاص ندهید](#assign-to-pod)، Kubernetes حساب خدماتی `default` برای آن فضای نام به Pod اختصاص می‌دهد.

## موارد استفاده از حساب‌های خدماتی Kubernetes {#use-cases}

به عنوان یک راهنمای کلی، می‌توانید از حساب‌های خدماتی برای ارائه هویت در موارد زیر استفاده کنید:

* نیاز دارید تا Pods شما با سرور API Kubernetes ارتباط برقرار کنند، به عنوان مثال در مواردی مانند:
  * ارائه دسترسی فقط خواندنی به اطلاعات حساس ذخیره‌شده در Secrets.
  * اجازه [دسترسی از چندین فضای نام](#cross-namespace)، مانند اینکه به یک Pod در فضای نام `example` اجازه دهید برای لیست کردن و پیگیری اشیاء Lease در فضای نام `kube-node-lease` را داشته باشد.
* Pods شما نیاز دارند تا با یک سرویس خارجی ارتباط برقرار کنند. به عنوان مثال، یک Pod بارگیری نیازمند هویت برای یک API ابر تجاری است و ارائه دهنده تجاری اجازه برپایی یک رابط اعتماد مناسب را می‌دهد.
* [احراز هویت در یک رجیستری تصویر خصوصی با استفاده از `imagePullSecret`](/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account).
* یک سرویس خارجی نیاز دارد تا با سرور API Kubernetes ارتباط برقرار کند. به عنوان مثال، احراز هویت به عنوان بخشی از یک خط لوله CI/CD به خوشه.

* شما از نرم‌افزارهای امنیتی شخص ثالث در خوشه خود استفاده می‌کنید که بر اساس هویت ServiceAccount انواع مختلف Pods را به گروه‌های مختلفی گروه‌بندی می‌کنند.

## چگونگی استفاده از حساب‌های خدماتی {#how-to-use}

برای استفاده از حساب‌های خدماتی Kubernetes، شما به مراحل زیر اقدام می‌کنید:

1. از یک مشتری Kubernetes مانند `kubectl` یا یک مانیفست که شیء را تعریف می‌کند، یک شیء ServiceAccount ایجاد کنید.
1. مجوزها را به شیء ServiceAccount با استفاده از یک مکانیزم اجازه‌دهی مانند [RBAC](/docs/reference/access-authn-authz/rbac/) اعطا کنید.
1. در هنگام ایجاد Pod، شیء ServiceAccount را به Pods اختصاص دهید.

   اگر از هویت یک سرویس خارجی استفاده می‌کنید، [توکن ServiceAccount را دریافت](#get-a-token) و از آن سرویس استفاده کنید.

برای دستورالعمل‌ها، به [پیکربندی حساب‌های خدماتی برای Pods](/docs/tasks/configure-pod-container/configure-service-account/) مراجعه کنید.

### اعطای مجوز به یک ServiceAccount {#grant-permissions}

شما می‌توانید از مکانیزم اجازه‌دهی [role-based access control (RBAC)](/docs/reference/access-authn-authz/rbac/) Kubernetes استفاده کنید تا حداقل مجوزهای مورد نیاز توسط هر حساب‌خدماتی را اعطا کنید. شما یک *role* ایجاد می‌کنید که دسترسی می‌دهد، و سپس نقش را به ServiceAccount خود می‌بندید. RBAC به شما امکان می‌دهد تا مجوزهای حداقلی را تعریف کنید به طوری که مجوزهای حساب‌های خدماتی به اصول حداقلی مطابقت داشته باشند. Pods که از آن حساب‌خدماتی استفاده می‌کنند، بیشتر از مجوزهای لازم برای صحیح کارکرد دسترسی ندارند.

برای دستورالعمل‌ها، به [مجوزهای ServiceAccount](/docs/reference/access-authn-authz/rbac/#service-account-permissions) مراجعه کنید.

#### دسترسی از فضای نام متقابل با استفاده از ServiceAccount {#cross-namespace}

شما می‌توانید از RBAC استفاده کنید تا حساب‌های خدماتی در یک فضای نام، عملیاتی را بر روی منابع در یک فضای نام دیگر در خوشه اجازه دهید. به عنوان مثال، در نظر بگیرید که یک حساب خدماتی و Pod در فضای نام `dev` دارید و می‌خواهید Pod خود را برای مشاهده Jobs در حال اجرا در فضای نام `maintenance` اجازه دهید. شما می‌توانید یک شیء Role ایجاد کنید که دسترسی‌ها را برای لیست کردن اشیاء Job اعطا می‌کند. سپس، یک شیء RoleBinding را در فضای نام `maintenance` ایجاد کنید تا Role را به شیء ServiceAccount ببندد. حالا، Pods در فضای نام `dev` می‌توانند از حساب‌های خدماتی استفاده کنند تا اشیاء Job را در فضای نام `maintenance` لیست کنند.

### اختصاص ServiceAccount به یک Pod {#assign-to-pod}

برای اختصاص یک ServiceAccount به یک Pod، فیلد `spec.serviceAccountName` را در مشخصات Pod تنظیم کنید. سپس Kubernetes به صورت خودکار اعتبارات را برای آن ServiceAccount به Pod فراهم می‌کند. در نسخه 1.22 و بعدی، Kubernetes توکنی با مدت زمان کوتاه، **به صورت خودکار چرخشی** با استفاده از API `TokenRequest` دریافت می‌کند و توکن را به عنوان یک [حجم پیش‌بینی‌شده](/docs/concepts/storage/projected-volumes/#serviceaccounttoken) نصب می‌کند.

به طور پیش‌فرض، Kubernetes برای Pod اعتبارات را برای ServiceAccount مشخص شده یا ServiceAccount `default` فراهم می‌کند.

برای جلوگیری از درجه‌بندی خودکار Kubernetes اعتبارات برای یک ServiceAccount مشخص یا ServiceAccount `default`، فیلد `automountServiceAccountToken` را در مشخصات Pod خود به `false` تنظیم کنید.

<!-- این جزئیات تاریخی را پس از انتشار Kubernetes 1.31 می‌توانید حذف کنید -->

در نسخه‌های قبل از 1.22، Kubernetes یک توکن ثابت، طولانی مدت را به عنوان یک Secret به Pod ارائه می‌دهد.

#### دریافت دستی اعتبارهای حساب خدماتی {#get-a-token}

اگر نیاز دارید تا اعتبارهای یک حساب خدماتی را برای نصب در یک مکان غیر استاندارد
یا برای مخاطبی که سرور API نیست، از یکی از روش‌های زیر استفاده کنید:

* [TokenRequest API](/docs/reference/kubernetes-api/authentication-resources/token-request-v1/)
  (توصیه می‌شود): یک توکن حساب خدماتی کوتاه مدت از کد *برنامه‌ی شما* درخواست کنید. این توکن به طور خودکار منقضی می‌شود و می‌تواند در صورت انقضاء چرخشی شود.
  اگر برنامه‌ی ارثی استفاده نکند که از Kubernetes آگاه نیست، می‌توانید از یک کانتینر sidecar داخل همان pod برای بارگیری این توکن‌ها استفاده کنید
  و آن‌ها را برای بارگذاری بارگیری در دسترس برنامه قرار دهید.
* [تصویر توکن حجم پیش‌بینی](/docs/tasks/configure-pod-container/configure-service-account/#serviceaccount-token-volume-projection)
  (نیز توصیه می‌شود): در Kubernetes v1.20 و بعد، از مشخصات Pod برای افزودن توکن حساب خدماتی به Pod به عنوان
  *حجم پیش‌بینی شده* استفاده کنید. توکن‌های پیش‌بینی شده به طور خودکار منقضی می‌شوند و kubelet
  توکن را قبل از انقضاء چرخش می‌دهد.
* [رمزهای توکن حساب خدماتی](/docs/tasks/configure-pod-container/configure-service-account/#manually-create-an-api-token-for-a-serviceaccount)
  (توصیه نمی‌شود): شما می‌توانید رمزهای حساب خدماتی را به عنوان رمزهای مخفی Kubernetes
  به Pod ها نصب کنید. این توکن‌ها منقضی نمی‌شوند و چرخش نمی‌کنند. در نسخه‌های قبل از v1.24، یک توکن دائمی برای هر حساب خدماتی به طور خودکار ایجاد می‌شد.
  این روش به ویژه در مقیاس بزرگ، به دلیل مخاطرات مربوط به اعتبارات استاتیک و طولانی مدت، دیگر توصیه نمی‌شود. یکی از ویژگی‌های
  از بین رفته، که در v1.27 از وضعیت GA بالا رفته است، پیوند ثابت
  LegacyServiceAccountTokenNoAutoGeneration را، جلوگیری از ایجاد خودکار این توکن‌ها برای
  ServiceAccounts. علت از بین رفتن در v1.27 بالا است که هنوز می‌توانید توکن‌های حساب خدماتی بی‌نهایت را به طور دستی ایجاد کنید، اما باید به مشکلات امنیتی دقت داشته باشید.

{{< note >}}
برای برنامه‌هایی که خارج از خوشه Kubernetes شما اجرا می‌شوند، ممکن است در نظر داشته باشید
ایجاد یک توکن حساب خدماتی طولانی مدت که در یک Secret ذخیره شده است. این اجازه می‌دهد تا احراز هویت انجام شود، اما پروژه Kubernetes توصیه می‌کند از این رویه پرهیز کنید.
توکن‌های بلند مدت به عنوان یک خطر امنیتی در نظر گرفته می‌شوند زیرا هنگام افشای آن، ممکن است از توکن سوءاستفاده شود. به جای این کار، در نظر بگیرید که از یک رویه جایگزین استفاده کنید. به عنوان مثال، برنامه خارجی شما می‌تواند با استفاده از یک کلید خصوصی که به خوبی محافظت شده است و یک گواهی،
یا استفاده از یک مکانیزم سفارشی مانند [احراز هویت webhook](/docs/reference/access-authn-authz/authentication/#webhook-token-authentication) که خود شما پیاده سازی می‌کنید.

همچنین می‌توانید از TokenRequest استفاده کنید تا توکن‌های کوتاه مدت برای برنامه خارجی خود بدست آورید.
{{< /note >}}

### محدود کردن دسترسی به رمزها {#enforce-mountable-secrets}

Kubernetes یک نشانگان به نام `kubernetes.io/enforce-mountable-secrets`
را فراهم می‌کند که می‌توانید به حساب‌های خدماتی خود اضافه کنید. هنگامی که این نشانگان اعمال می‌شود،
رمزهای حساب خدماتی فقط می‌توانند بر روی انواع خاصی از منابع نصب شوند،
امنیت خوشه شما را افزایش می‌دهد.

می‌توانید این نشانگان را به یک حساب خدماتی با استفاده از یک مانیفست اضافه کنید:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  annotations:
    kubernetes.io/enforce-mountable-secrets: "true"
  name: my-serviceaccount
  namespace: my-namespace
```

زمانی که این نشانگان به "true" تنظیم شود، سیستم کنترل Kubernetes اطمینان حاصل می‌کند که
رمزهای این حساب خدماتی تحت محدودیت‌های خاصی از نوع نصب قرار دارند.

1. نام هر Secret که به عنوان یک حجم در Pod نصب شده است، باید در فیلد `secrets` از
   ServiceAccount Pod ظاهر شود.
1. ن

ام هر Secret که با استفاده از `envFrom` در یک Pod مشخص شده است، باید همچنین در `secrets` ظاهر شود.
   از Pod ServiceAccount.
1. نام هر Secret که با استفاده از `imagePullSecrets` در یک Pod مشخص شده است، باید همچنین در `secrets` ظاهر شود.
   از Pod ServiceAccount.

با درک و اعمال این محدودیت‌ها، مدیران خوشه می‌توانند یک پروفایل امنیتی شدیدتر را حفظ کنند و اطمینان حاصل کنند که رمزها فقط توسط منابع مناسب دسترسی پیدا می‌کنند.

## احراز هویت اعتبارات حساب خدماتی {#authenticating-credentials}

ServiceAccounts از جوکن‌های توکن JSON (JWTs) امضا شده
برای احراز هویت به سرور API Kubernetes، و به هر سیستم دیگری که یک
روابط اعتماد وجود دارد. بسته به این که توکن چگونه صادر شده است
(با استفاده از TokenRequest با محدوده مشخص یا با استفاده از مکانیزم ارثی با
رمز، توکن حساب خدماتی ممکن است دارای زمان انقضاء، مخاطب و زمانی باشد که توکن
شروع به اعتبار می‌کند. وقتی که یک مشتری که به عنوان یک حساب خدماتی عمل می‌کند
سعی در ارتباط با سرور API Kubernetes دارد، مشتری شامل یک `Authorization: Bearer <token>` با عنوان HTTP
درخواست. سرور API اعتبار توکن را به شرح زیر بررسی می‌کند:

1. امضای توکن را بررسی می‌کند.
1. بررسی می‌کند که توکن منقضی شده است یا خیر.
1. بررسی می‌کند که ارجاعات شیء در دعوتنامه کلیمات فعلی است.
1. بررسی می‌کند که توکن در حال حاضر معتبر است.
1. کلیمات مخاطب را بررسی می‌کند.

API توکن‌های مرتبط برای حساب‌های خدماتی ارائه می‌دهد. این
پیوند به عمر مفصلی از مشتری، مانند یک Pod، که به عنوان آن عمل می‌کند
حساب خدماتی. برای مثال یک توکن موضعی پیش‌بینی شده را ببینید
برای جزئیات بیشتر مخمصه JWT و بار مفصل.

برای توکن‌های صادر شده با استفاده از API TokenRequest، سرور API همچنین چک می‌کند که
مرجع شیء خاصی که از حساب خدماتی استفاده می‌کند هنوز هست،
با استفاده از شناسه یکتای که از آن شیء استفاده می‌کند. برای توکن‌های قدیمی که به عنوان رمزها نصب شده‌اند
در پادها، سرور API توکن را با Secret چک می‌کند.

برای اطلاعات بیشتر در مورد فرآیند احراز هویت، به
[Authentication](/docs/reference/access-authn-authz/authentication/#service-account-tokens) مراجعه کنید.

### احراز هویت اعتبارات حساب خدماتی در کد خود {#authenticating-in-code}

اگر سرویس‌های خود را دارید که نیاز به اعتبار حساب خدماتی Kubernetes دارند، می‌توانید از روش‌های زیر استفاده کنید:

* [TokenReview API](/docs/reference/kubernetes-api/authentication-resources/token-review-v1/)
  (توصیه می‌شود)
* کشف OIDC

پروژه Kubernetes توصیه می‌کند که از TokenReview API استفاده کنید، زیرا
این روش توکن‌ها را که به اشیاء API مانند Secret، ServiceAccounts، Pod یا Nodes بسته شده‌اند، نامعتبر می‌کند زمانی که این اشیاء حذف می‌شوند. برای مثال، اگر شما
پاد را که حاوی یک توکن حساب خدماتی پیش‌بینی شده است، حذف کنید، خوشه
این توکن را فوراً نامعتبر می‌کند و یک TokenReview فوراً ناموفق است.
اگر از اعتبار سنجی OIDC استفاده کنید، مشتریان شما ادامه می‌دهند تا توکن
را به عنوان معتبر در نظر بگیرید تا زمانی که توکن به زمان انقضا خود برسد.

برنامه شما باید همیشه مخاطبی را که می‌پذیرد، تعریف کند و باید
بررسی کنید که مخاطبان توکن با مخاطبانی همخوانی دارند که برنامه
انتظار دارد. این کمک می‌کند تا دامنه توکن را به حداقل برسانید به طوری که فقط
در برنامه‌ی شما و هیچ جای دیگری استفاده می‌شود.

## جایگزین‌ها

* صادر کردن توکن‌های خود را با استفاده از یک مکانیزم دیگر و سپس استفاده کنید
  [احراز هویت webhook](/docs/reference/access-authn-authz/authentication/#webhook-token-authentication)
  برای اعتبار سنجی توکن‌های کننده با استفاده از سرویس اعتبار سنجی خود.
* ارائه هویت خود را به Pods.
  * [استفاده از افزونه درایور SPIFFE CSI برای ارائه SVIDهای SPIFFE به عنوان جفت گواهی X.509 به Pods](

https://cert-manager.io/docs/projects/csi-driver-spiffe/).
    {{% thirdparty-content single="true" %}}
  * [استفاده از یک شبکه خدماتی مانند Istio برای ارائه گواهی‌نامه به Pods](https://istio.io/latest/docs/tasks/security/cert-management/plugin-ca-cert/).
* احراز هویت از خارج از خوشه به سرور API بدون استفاده از توکن حساب خدماتی:
  * [پیکربندی سرور API برای پذیرش توکن‌های OpenID Connect (OIDC) از ارائه دهنده هویت شما](/docs/reference/access-authn-authz/authentication/#openid-connect-tokens).
  * استفاده از حساب‌های خدماتی یا حساب‌های کاربری ایجاد شده با استفاده از یک
    و مدیریت دسترسی (IAM) خارجی مانند از ارائه دهنده ابر، برای احراز هویت به خوشه خود.
  * [استفاده از API CertificateSigningRequest با گواهی‌نامه‌های مشتری](/docs/tasks/tls/managing-tls-in-a-cluster/).
* [پیکربندی kubelet برای دریافت اعتبارات از یک رجیستری تصویر](/docs/tasks/administer-cluster/kubelet-credential-provider/).
* استفاده از یک افزونه دستگاه برای دسترسی به ماژول امنیتی پلتفرم معتمد مجازی (TPM)، که
  سپس اجازه احراز هویت با استفاده از یک کلید خصوصی را می‌دهد.

## {{% heading "whatsnext" %}}

* یاد بگیرید که [حساب‌های خدماتی خود را به عنوان یک مدیر خوشه مدیریت کنید](/docs/reference/access-authn-authz/service-accounts-admin/).
* یاد بگیرید که [یک حساب خدماتی را به یک Pod اختصاص دهید](/docs/tasks/configure-pod-container/configure-service-account/).
