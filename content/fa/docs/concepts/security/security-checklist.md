---
title: چک لیست امنیتی
description: >
  چک لیست پایه برای اطمینان از امنیت در خوشه‌های Kubernetes.
content_type: concept
weight: 100
---

<!-- overview -->

این چک لیست هدف دارد که فهرستی از راهنماهای پایه‌ای را ارائه دهد که به هر موضوع بهترین دستورالعمل‌ها مراجعه نمی‌کند و می‌خواهد که تحول کند.

درباره چگونگی خواندن و استفاده از این سند:

- ترتیب موضوعات برتری یا عدم برتری را نشان نمی‌دهد.
- برخی از موارد چک لیست در پاراگراف زیر لیست هر بخش توضیح داده شده است.

{{< caution >}}
چک لیست‌ها به تنهایی کافی نیستند برای به دست آوردن یک وضعیت امنیتی خوب. یک وضعیت امنیتی خوب نیازمند توجه و بهبود مداوم است، اما یک چک لیست می‌تواند اولین قدم در مسیر بی‌پایان به سوی آمادگی امنیتی باشد. برخی از توصیه‌ها در این چک لیست ممکن است برای نیازهای امنیتی خاص شما خیلی محدود یا خیلی آزاد باشند. امنیت Kubernetes "یک سایز برای همه" نیست و هر دسته از موارد چک لیست باید بر اساس مزایای آن ارزیابی شود.
{{< /caution >}}

<!-- body -->

## احراز هویت و مجوزدهی

- [ ] گروه `system:masters` بعد از نصب اولیه برای احراز هویت کاربر یا اجزا استفاده نمی‌شود.
- [ ] `kube-controller-manager` با گزینه `--use-service-account-credentials` فعال است.
- [ ] گواهی ریشه محافظت می‌شود (یا یک CA آفلاین، یا CA آنلاین مدیریت شده با کنترل دسترسی موثر).
- [ ] گواهی‌نامه‌های میانی و برگه دارای یک تاریخ انقضای حداکثر 3 سال آینده هستند.
- [ ] یک فرآیند برای مرور دوره‌ای دسترسی وجود دارد و مرورها حداکثر هر 24 ماه یک بار انجام می‌شود.
- [ ] [روش‌های خوب مجوزدهی مبتنی بر نقش](/docs/concepts/security/rbac-good-practices/) برای راهنمایی مربوط به احراز هویت و مجوزدهی دنبال می‌شوند.

پس از نصب اولیه، هیچ کاربر یا مولفه‌ای به API Kubernetes به عنوان `system:masters` احراز هویت نمی‌شود. به همین منظور، اجرای کل kube-controller-manager به عنوان `system:masters` باید از دسترس خارج شود. در واقع، `system:masters` فقط باید به عنوان یک مکانیزم اضطراری استفاده شود، به جای یک کاربر مدیریتی.

## امنیت شبکه

- [ ] پلاگین‌های CNI مورد استفاده، سیاست‌های شبکه را پشتیبانی می‌کنند.
- [ ] سیاست‌های شبکه ورودی و خروجی به همه بارگیری‌ها در خوشه اعمال می‌شود.
- [ ] سیاست‌های شبکه پیش‌فرض در هر فضای نام، انتخاب همه پادها، همه چیز را ممنوع می‌کنند.
- [ ] در صورت لزوم، یک شبکه خدمت برای رمزگذاری تمام ارتباطات داخل خوشه استفاده می‌شود.
- [ ] API Kubernetes، kubelet API و etcd به صورت عمومی در اینترنت قرار داده نمی‌شود.
- [ ] دسترسی از بارگیری‌ها به API فضای‌های ابری متادیت فیلتر می‌شود.
- [ ] استفاده از LoadBalancer و ExternalIPs محدود شده است.

بسیاری از [پلاگین‌های رابط شبکه کانتینر](/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)
پشتیبانی از تابعیت از منابع شبکه است که می‌تواند با کانتینرها ارتباط برقرار کند. این بیشتر از طریق [سیاست‌های شبکه](/docs/concepts/services-networking/network-policies/)
که یک منبع فضای‌دهنده تعریف قوانین را ارائه می‌دهد، انجام می‌شود. سیاست‌های شبکه پیش‌فرض برش همه ورودی و خروجی، در هر فضای نام، انتخاب تمام پاد‌ها می‌تواند به عنوان رویکرد لیست مجاز استفاده شده‌ای از اطلاعات.

همه پلاگین‌های CNI امکان ارتباط در حالت معین را فراهم می‌کنند. اگر پلاگین انتخاب شده این ویژگی را ندارد، راه‌حل جایگزین را می‌توان به کمک خدمات شبکه استفاده کرد.

ذخیره‌سازی etcd از خوشه کنترل باید کنترل‌ها داشته باشد که به محدودیت‌های محدود و امنیتی نباید به عمومی دسترسی داشته باشد. علاوه بر این، ارتباط مطمئن TLS (mTLS) باید استفاده شود تا با آن ارتباط داشته باشد. این سوال باید یک ثبت مخصوص این امر باشد.

دسترسی از سرورهای بارگذاری که از خدمات‌دهنده‌های ابر استفاده می‌کنند، باید از API آدرس API `169.254.169.254` در معرض خطر بوده و اگر از آن نیاز ندارد به اطلاعات که می‌تواند نشت داده است.

برای محدود کردن LoadBalancer و ExternalIPs به CVE-2020-8554: Man in the middle using LoadBalancer یا ExternalIPs و [کنترل کننده ورود DenyServiceExternalIPs](/docs/reference/access-authn-authz/admission-controllers/#denyserviceexternalips)
را برای اطلاعات بیشتر مشاهده کنید.

## امنیت پاد

- [ ] حقوق RBAC برای `create`, `update`, `patch`, `delete` بارگیری فقط در صورت لزوم اعطا شده است.
- [ ] برای همه فضای نام‌ها، استانداردهای امنیتی پلیسی مربوطه برای کلیه فضای‌ها اعمال شده و اجرا می‌شود.
- [ ] محدودیت حافظه برای بارگیری‌ها با یک حداکثر محدودیت برابر یا پایین‌تر از درخواست تنظیم شده است.
- [ ] ممکن است حدود CPU برای بارگیری‌های حساس تنظیم شود.
- [ ] برای سرورهایی که پشتیبانی می‌کنند، Seccomp با پروفایل syscalls مناسب برای برنامه‌ها فعال شده است.
- [ ] برای سرورهایی که پشتیبانی می‌کنند، AppArmor یا SELinux با پروفایل مناسب برای برنامه‌ها فعال شده است.

اجازه RBAC از اهمیت بالایی برخوردار است، اما
[قابلیت تجزیه و تحلیل مجوزهای RBAC برای ایجاد](/docs/concepts/security/rbac-good-practices/#workload-creation)
(یا هر منبع دیگری که بارگیری‌ها را مدیریت می‌کند). تنها دقت API است که فقط اجازه می‌دهد انجام عملیات بر روی منبع خود است، برای مثال، `create` در بارگیری. بدون
اعتبارات
[اضافی](/docs/concepts/security/rbac-good-practices/#workload-creation)
به ایجاد این منابع اجازه می‌دهد که دسترسی مستقیم بدون محدودیت به نودهای قابل برنامه‌ریزی یک خوشه ارائه دهد.

[استانداردهای امنیتی بارگیری‌ها](/docs/concepts/security/pod-security-standards/)
سه سیاست مختلف، خصوصی، پایه‌گذاری و محدود که محدودیت‌ها در مورد اینکه چگونه فیلدها را می‌توان برای `PodSpec` با امنیت مرتبط تعیین کرد. این استانداردها می‌تواند در سطح فضای‌های نام با ورودی جدید
[اجازه بارگیری](/docs/concepts/security/pod-security-admission/)
فعال شده به طور پیش‌فرض، یا توسط وب‌های اجازه خارجی اجبار داده شود. لطفاً توجه داشته باشید که، بر خلاف [حذف شده است](/docs/concepts/security/pod-security-admission/)
است ورود اجازه پذیرش امکان دارد که به راحتی با وب‌های اجازه و سرویس‌های خارجی ترکیب شود.

وقتی که فضای‌های نام مجازی اجازه بارگذاری `محدود` برای اعمال امنیت‌های محدود ترین است
[از استانداردهای امنیتی بارگیری‌ها](/docs/concepts/security/pod-security-standards/)
را
[برچسب‌های بارگذاری اجازه بارگیری](/docs/concepts/security/pod-security-admission/#pod-security-admission-labels-for-namespaces),
`هشدار`، `آزمون` یا `اجرا` برای به تدریج بهترین اجرای معماری امنیتی برای روش‌های بهترین تمرین‌های امنیتی متناسب با مطالب خود.

برای آموزش عملی در مورد [امنیت بارگذاری](/docs/concepts/security/pod-security-admission/),
پست وبلاگ
[Kubernetes 1.23: Pod Security Graduates to Beta](/blog/2021/12/09/pod-security-admission-beta/)
را بررسی کنید.

[محدودیت‌های حافظه و CPU](/docs/concepts/configuration/manage-resources-containers/)
باید برای محدود کردن حافظه و منابع CPU که یک بارگذاری می‌تواند روی یک نود مصرف کند، تنظیم شود و بنابراین می‌تواند جلوگیری از حمله DoS از بارگیری‌های بدیهی یا نقض شده باشد. این سیاست می‌تواند توسط کنترل‌گرهای اجازه اجرا شود.
لطفا توجه داشته باشید که محدودیت CPU به صورت خودکار برای استفاده از پیام های بهترین تلاش ممکن است باعث اثرات ناخواسته در ویژگی‌های خودکار شود یا بهره وری i.e. اجرای فرایند با موجودی منابع پردازنده.

{{< caution >}}
حافظه بیشتر از درخواست می‌تواند به مشکلات OOM ارائه دهد.
{{< /caution >}}
### فعال‌سازی Seccomp

Seccomp به معنای حالت محاسبات امن است و از نسخه ۲.۶.۱۲ هسته لینوکس به بعد یک ویژگی است. این ویژگی می‌تواند برای محدود کردن دسترسی‌هایی که یک فرآیند می‌تواند از فضای کاربری به هسته لینوکس داشته باشد، مورد استفاده قرار گیرد. Kubernetes به شما امکان می‌دهد تا پروفایل‌های Seccomp را که بر روی یک نود بارگذاری شده‌اند را به طور خودکار بر روی Pods و کانتینرهای خود اعمال کنید.

Seccomp می‌تواند با کاهش سطح حمله‌پذیری syscall های هسته لینوکس داخل کانتینرها، امنیت بار کاری شما را بهبود بخشد. حالت فیلتر Seccomp از BPF بهره می‌برد تا یک لیست مجاز یا غیرمجاز از syscall های خاص را به نام پروفایل‌ها ایجاد کند.

از نسخه ۱.۲۷ Kubernetes، شما می‌توانید استفاده از `RuntimeDefault` را به عنوان پروفایل Seccomp پیش‌فرض برای تمام بارگذاری‌ها فعال کنید. یک [آموزش امنیتی](/docs/tutorials/security/seccomp/) در این زمینه موجود است. همچنین، [اپراتور پروفایل‌های امنیتی Kubernetes](https://github.com/kubernetes-sigs/security-profiles-operator) یک پروژه است که مدیریت و استفاده از Seccomp را در خوشه‌ها را آسان می‌کند.

{{< note >}}
Seccomp فقط بر روی نودهای لینوکس در دسترس است.
{{< /note >}}

### فعال‌سازی AppArmor یا SELinux

#### AppArmor

[AppArmor](/docs/tutorials/security/apparmor/) یک ماژول امنیتی هسته لینوکس است که می‌تواند از طریق کنترل دسترسی اجباری (MAC) و بهترین آدمینیستری از طریق لاگ‌های سیستم، راه‌های ساده‌ای برای اجرای کنترل دسترسی‌های اجباری فراهم کند. یک پروفایل پیش‌فرض AppArmor بر روی نودها اجباری است که پشتیبانی می‌شود، یا می‌توان یک پروفایل سفارشی را پیکربندی کرد. مانند Seccomp، AppArmor هم از طریق پروفایل‌ها پیکربندی می‌شود که هر پروفایل به حالت اجرایی که دسترسی به منابع غیرمجاز را مسدود می‌کند یا حالت شکایت که فقط نقض‌ها را گزارش می‌دهد، عمل می‌کند. پروفایل‌های AppArmor بر روی هر کانتینر به صورت پیش‌فرض اجرا می‌شوند، با یک آنوتیشن که به فرآیندها اجازه می‌دهد تا دسترسی‌های مناسب را به دست آورند.

{{< note >}}
AppArmor فقط بر روی نودهای لینوکس در دسترس است و در برخی توزیع‌های لینوکس فعال است.
{{< /note >}}

#### SELinux

[SELinux](https://github.com/SELinuxProject/selinux-notebook/blob/main/src/selinux_overview.md) نیز یک ماژول امنیتی هسته لینوکس است که می‌تواند یک مکانیزم برای پشتیبانی از سیاست‌های کنترل دسترسی، شامل کنترل دسترسی‌های اجباری (MAC) فراهم کند. برچسب‌های SELinux می‌توانند به کانتینرها یا Pods اختصاص داده شوند [از طریق بخش `securityContext`](/docs/tasks/configure-pod-container/security-context/#assign-selinux-labels-to-a-container).

{{< note >}}
SELinux فقط بر روی نودهای لینوکس در دسترس است و در برخی توزیع‌های لینوکس فعال است.
{{< /note >}}

## لاگ‌ها و حسابرسی

- [ ] لاگ‌های حسابرسی، اگر فعال شده باشند، از دسترسی عمومی محافظت می‌شوند.

## قرارگیری Pods

- [ ] قرارگیری Pods با توجه به سطوح حساسیت برنامه‌ها انجام می‌شود.
- [ ] برنامه‌های حساس در نودها به طور جداگانه اجرا می‌شوند یا با زمان اجرای محدود محافظت شده‌اند.

Pods که در سطوح حساسیت متفاوتی قرار دارند، به عنوان مثال یک pod برنامه و سرور API Kubernetes، باید بر روی نودهای جداگانه اجرا شوند. هدف از جدا سازی نود، جلوگیری از شکستن کانتینر برنامه به طور مستقیم به دسترسی به برنامه‌های با سطح حساسیت بالاتر است که باعث آسانی پیوت درون خوشه می‌شود. این جدا سازی برای جلوگیری از اشتباهات در اجرای Pods روی همان نود باید اعمال شود. این می‌تواند با ویژگی‌های زیر اعمال شود:

[Node Selectors](/docs/concepts/scheduling-eviction/assign-pod-node/)
: جفت‌های کلیدی-مقدار، به عنوان بخشی از مشخصات pod که مشخص می‌کنند که کدام نودها باید بر روی آن‌ها اجرا شوند. این می‌تواند در سطح فضای نام و خوشه با کنتر

ل کننده مجوزهای [PodNodeSelector](/docs/reference/access-authn-authz/admission-controllers/#podnodeselector) اجباری اعمال شود.

[PodTolerationRestriction](/docs/reference/access-authn-authz/admission-controllers/#podtolerationrestriction)
: یک کنترل کننده پذیرشی که به مدیران اجازه می‌دهد تا محدودیت‌های مجازی را در یک فضای نام اعمال کنند. Pods در یک فضای نام فقط می‌توانند از مجازی‌های مجازی استفاده کنند که در کلیدهای شی جادویی فضای نام مشخص شده است که مجوزهای پیش‌فرض و مجازی مجازی را ارائه می‌دهد.

[RuntimeClass](/docs/concepts/containers/runtime-class/)
: RuntimeClass یک ویژگی برای انتخاب پیکربندی راننده کانتینر است. پیکربندی راننده کانتینر برای اجرای کانتینرهای یک pod استفاده می‌شود و می‌تواند از ایزوله بیشتر یا کمتری از میزبان با هزینه عملکرد بهره‌وری ارائه دهد.

## رازها

- [ ] ConfigMaps برای نگهداری داده‌های محرمانه استفاده نمی‌شوند.
- [ ] رمزگذاری در استراحت برای API رازها پیکربندی شده است.
- [ ] اگر مناسب باشد، مکانیسمی برای وارد کردن رمزهای ذخیره شده در ذخیره سوم ارائه شده و در دسترس است.
- [ ] Token‌های حساب سرویس در Pods که به آنها نیاز ندارند، نصب نمی‌شوند.
- [ ] [حجم متصل شده‌ی حجم حساب سرویس](/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume)
  به جای Token‌های غیرمنقضی استفاده می‌شود.

رمزهای مورد نیاز برای pods باید در Kubernetes Secrets نگهداری شوند به جای جایگزینی‌هایی مانند ConfigMap. منابع Secret که در etcd نگهداری می‌شوند باید [در استراحت رمزگذاری شوند](/docs/tasks/administer-cluster/encrypt-data/).

Pods نیازمند رمزها باید این‌ها را به طور خودکار از طریق حجم‌ها نصب کنند، بهترین‌ اینکه ذخیره شود در حافظه مانند گزینه‌ی [`emptyDir.medium`](/docs/concepts/storage/volumes/#emptydir).
مکانیسم می‌تواند استفاده شود تا رمزهای از ذخایر ذخیره شود به طور محرمانه،  مانند [Secrets Store CSI Driver](https://secrets-store-csi-driver.sigs.k8s.io/).
به طور ترجیحی این باید مقایسه شود تا به Pods مجوز RBAC اسرار دسترسی مشخص شود. این اجازه دهید رمزها را به پویای فضای کاری فرآیند غیرمحرمانه  در لاگ‌ها  می‌شود

## تصاویر

- [ ] کمینه‌سازی محتوای غیرضروری در تصاویر کانتینر.
- [ ] تنظیمات تصاویر کانتینر برای اجرا به عنوان کاربر غیراستثنایی انجام شده باشد.
- [ ] ارجاع‌ها به تصاویر کانتینر با استفاده از دیجست sha256 (به جای برچسب‌ها) صورت گرفته باشد یا اصالت تصویر با تایید امضای دیجیتال آن در زمان استقرار [توسط کنترل ورودی](/docs/tasks/administer-cluster/verify-signed-artifacts/#verifying-image-signatures-with-admission-controller) تأیید شده باشد.
- [ ] تصاویر کانتینر به طور منظم در زمان ایجاد و در استقرار اسکن می‌شوند و نرم‌افزارهای آسیب‌پذیر شناخته‌شده پچ می‌شوند.

تصویر کانتینر باید حاوی کمینه‌ای از اجزا باشد که برای اجرای برنامه لازم است. بهتر است تنها برنامه و وابستگی‌های آن در تصویر قرار گیرند و از پایه‌ای کمینه‌ای شروع به ساخت تصویر کنید. به ویژه، تصویر‌های استفاده شده در محصول نباید حاوی پوسته‌ها یا ابزارهای اشکال‌زدایی باشند، زیرا می‌توان از یک [کانتینر اشکال‌زدایی موقت](/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container) برای رفع اشکال استفاده کرد.

ساخت تصاویر به‌طور مستقیم با کاربر غیراستثنایی با استفاده از دستور `USER` در فایل Dockerfile انجام شود. [محیط امنیتی](/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod) اجازه می‌دهد که تصویر کانتینر با کاربر و گروه خاصی آغاز شود با استفاده از `runAsUser` و `runAsGroup`، حتی اگر در نمای کلی تصویر مشخص نشده باشد. با این حال، مجوزهای فایل در لایه‌های تصویر ممکن است باعث شود که اجرای فرآیند با کاربر غیراستثنایی جدید بدون اصلاح تصویر غیرممکن باشد.

از استفاده از برچسب‌ها برای ارجاع به یک تصویر کانتینر، به ویژه برچسب `latest`، خودداری شود، زیرا تصویر پشت یک برچسب به راحتی در یک رجیستری قابل تغییر است. بهتر است از دیجست کامل `sha256` که یکتاست برای نمای تصویر استفاده کنید. این سیاست می‌تواند از طریق یک [ImagePolicyWebhook](/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook) اجباری شود. امضای تصاویر همچنین می‌تواند به طور خودکار [در زمان استقرار با یک کنترل ورودی تایید شود](/docs/tasks/administer-cluster/verify-signed-artifacts/#verifying-image-signatures-with-admission-controller) تا اصالت و سلامت آنها را تأیید کند.

اسکن تصویر کانتینر می‌تواند جلوگیری از آسیب‌پذیری‌های اساسی را که همراه با تصویر کانتینر در خوشه قرار می‌گیرند، به اشتراک بگذارد. اسکن تصویر باید قبل از استقرار تصویر کانتینر در یک خوشه انجام شود و معمولاً به عنوان بخشی از فرآیند استقرار در یک خط لوله CI/CD انجام می‌شود. هدف از یک اسکن تصویر به دست آوردن اطلاعات درباره آسیب‌پذیری‌های ممکن و پیشگیری از آنها در تصویر کانتینر است، مانند [سیستم امتیازدهی آسیب‌پذیری مشترک (CVSS)](https://www.first.org/cvss/). اگر نتیجه اسکن تصویر با قوانین تطابق خط لوله ترکیب شود، تنها تصاویر کانتینر با پچ‌های مناسب در محصولات خروجی خواهند شد.

---

## کنترل‌کننده‌های پذیرش

- [ ] انتخاب مناسب از کنترل‌کننده‌های پذیرش فعال شده است.
- [ ] یک سیاست امنیتی پاد توسط کنترل‌کننده پذیرش امنیتی پاد یا/و یک
  کنترل‌کننده وب‌های پذیرش استفاده شده است.

کنترل‌کننده‌های پذیرش می‌توانند به بهبود امنیت خوشه کمک کنند. با این حال، آنها ممکن است خود ریسک‌هایی را ارائه دهند زیرا که API سرور را گسترش می‌دهند و [باید به درستی امن شوند](/blog/2022/01/19/secure-your-admission-controllers-and-webhooks/).

لیست‌های زیر تعدادی از کنترل‌کننده‌های پذیرش را که ممکن است برای به

بود وضعیت امنیتی خوشه و برنامه خود مورد استفاده قرار گیرند، معرفی می‌کند. این شامل کنترل‌کننده‌هایی است که ممکن است در بخش‌های دیگر این سند ارجاع شوند.

این اولین گروه از کنترل‌کننده‌های پذیرش شامل پلاگین‌هایی است که به طور پیش‌فرض [فعال شده‌اند](/docs/reference/access-authn-authz/admission-controllers/#which-plugins-are-enabled-by-default)، در نظر بگیرید که آنها را فعال بگذارید مگر اینکه بدانید چه می‌کنید:

[`CertificateApproval`](/docs/reference/access-authn-authz/admission-controllers/#certificateapproval)
: بررسی‌های مجوزی اضافی را برای اطمینان از اینکه کاربر تأیید کننده دسترسی لازم برای تأیید درخواست گواهی دارد.

[`CertificateSigning`](/docs/reference/access-authn-authz/admission-controllers/#certificatesigning)
: بررسی‌های مجوزی اضافی را برای اطمینان از اینکه کاربر امضایی دسترسی لازم برای امضای درخواست‌های گواهی دارد.

[`CertificateSubjectRestriction`](/docs/reference/access-authn-authz/admission-controllers/#certificatesubjectrestriction)
: رد درخواست گواهی که یک 'گروه' (یا ویژگی 'سازمان') از `system:masters` را مشخص می‌کند.

[`LimitRanger`](/docs/reference/access-authn-authz/admission-controllers/#limitranger)
: محدودیت‌های API LimitRange را اجرا می‌کند.

[`MutatingAdmissionWebhook`](/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook)
: امکان استفاده از کنترل‌کننده‌های سفارشی از طریق وب‌هاک را فراهم می‌کند، این کنترل‌کننده‌ها ممکن است درخواست‌ها را که بررسی می‌کند، تغییر دهد.

[`PodSecurity`](/docs/reference/access-authn-authz/admission-controllers/#podsecurity)
: جایگزین سیاست امنیتی پاد، محدودیت‌های محیط‌های امنیتی پادهای استقراری را محدود می‌کند.

[`ResourceQuota`](/docs/reference/access-authn-authz/admission-controllers/#resourcequota)
: سهمیه منابع را برای جلوگیری از مصرف بیش از حد منابع اجباری می‌کند.

[`ValidatingAdmissionWebhook`](/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook)
: امکان استفاده از کنترل‌کننده‌های سفارشی از طریق وب‌هاک را فراهم می‌کند، این کنترل‌کننده‌ها درخواست‌هایی را که بررسی می‌کنند، تغییر نمی‌دهند.

گروه دوم شامل پلاگین‌هایی است که به طور پیش‌فرض فعال نشده‌اند اما در دسترسی عمومی هستند و توصیه می‌شود برای بهبود وضعیت امنیتی خود:

[`DenyServiceExternalIPs`](/docs/reference/access-authn-authz/admission-controllers/#denyserviceexternalips)
: تمام استفاده‌های جدید شبکه از فیلد `Service.spec.externalIPs` را رد می‌کند. این یک کاهش برای [CVE-2020-8554: Man in the middle using LoadBalancer or ExternalIPs](https://github.com/kubernetes/kubernetes/issues/97076) است.

[`NodeRestriction`](/docs/reference/access-authn-authz/admission-controllers/#noderestriction)
: محدودیت‌های kubelet را به مدیریت تنها تغییر می‌دهد که از منابع API پادها که مالک آنها هستند یا منبع API نود که خودشان را نشان می‌دهند. همچنین جلوگیری می‌کند که kubelet از یادداشت `node-restriction.kubernetes.io/` استفاده کند که می‌تواند توسط یک حمله‌کننده با دسترسی به اعتبارات kubelet برای تأثیر گذاشتن بر قرارگاه pod به نود کنترل‌شده استفاده شود.

گروه سوم شامل پلاگین‌هایی است که به طور پیش‌فرض فعال نشده‌اند اما ممکن است برای موارد خاص مورد استفاده قرار گیرند:

[`AlwaysPullImages`](/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages)
: استفاده از آخرین نسخه تصویر برچسب‌دار را اجبار می‌دهد و اطمینان حاصل می‌کند که اجازه استفاده از تصویر را دارد.

[`ImagePolicyWebhook`](/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook)
: امکان اعمال کنترل‌های اضافی برای تصاویر از طریق وب‌هاک را فراهم می‌کند.

<!-- گروه چهارم شامل پلاگین‌هایی است که به طور پیش‌فرض فعال نشده‌اند، هنوز در حالت آلفا هستند اما ممکن است برای موارد خاص مورد استفاده قرار گیرند:

[`EventRateLimit`](/docs/reference/access-authn-authz/admission-controllers/#eventratelimit)
: محدودیت نرخ افزودن رویدادهای جدید به سرور API.

[`PodNodeSelector`](/docs/reference/access-authn-authz/admission-controllers/#podnodeselector)
: امکان کنترل انتخاب‌کننده‌های node در حیطه‌ها و سراسر فضای نام فراهم می‌کند.

[`PodTolerationRestriction`](/docs/reference/access-authn-authz/admission-controllers/#podtolerationrestriction)
: کنترل تحمل‌پذیری‌های پاد مجاز برای پادها در یک حیطه فضای نام فراهم می‌کند. -->

## چه بعدی

- [ارتقای دسترسی از طریق ایجاد پاد](/docs/reference/access-authn-authz/authorization/#privilege-escalation-v

ia-pod-creation)
  شما را در مورد یک ریسک کنترل دسترسی خاص هشدار می‌دهد؛ بررسی کنید که چگونه این تهدید را مدیریت می‌کنید.
  - اگر از RBAC Kubernetes استفاده می‌کنید، [روش‌های خوب RBAC](/docs/concepts/security/rbac-good-practices/) را برای اطلاعات بیشتر درباره مجوزها بخوانید.
- [امنیت خوشه](/docs/tasks/administer-cluster/securing-a-cluster/) برای
  اطلاعات بیشتر در مورد محافظت از یک خوشه در برابر دسترسی‌های تصادفی یا خبیث بخوانید.
- [راهنمای چند‌تانانی خوشه](/docs/concepts/security/multi-tenancy/) برای
  پیکربندی گزینه‌های پیشنهادی و بهترین شیوه‌ها در مورد چند‌تانیت بخوانید.
- [پست وبلاگ "نگاهی نزدیکتر به راهنمای سخت‌افزاری Kubernetes NSA/CISA"](/blog/2021/10/05/nsa-cisa-kubernetes-hardening-guidance/#building-secure-container-images)
  برای منبع تکمیلی درباره سخت‌افزاری خوشه‌های Kubernetes.


