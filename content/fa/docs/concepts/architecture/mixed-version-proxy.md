---
reviewers:
- jpbetz
title: Mixed Version Proxy
content_type: concept
weight: 220
---

<!-- overview -->

{{< feature-state feature_gate_name="UnknownVersionInteroperabilityProxy" >}}

کوبرنیتیز {{< skew currentVersion >}} شامل یک ویژگی آلفا است که به یک
{{< glossary_tooltip text="سرور API" term_id="kube-apiserver" >}}
اجازه می‌دهد درخواست‌های منابع را به سایر سرورهای API همتا پروکسی کند. این ویژگی زمانی مفید است که چندین
سرور API با نسخه‌های مختلف کوبرنیتیز در یک کلاستر اجرا می‌شوند
(برای مثال، در طول یک به‌روزرسانی طولانی مدت به یک نسخه جدید از کوبرنیتیز).

این ویژگی به مدیران کلاستر اجازه می‌دهد کلاسترهای با دسترسی بالا را با ایمنی بیشتر به‌روزرسانی کنند،
با هدایت درخواست‌های منابع (در حین به‌روزرسانی) به سرور API صحیح.
این پروکسی کردن از نمایش خطاهای 404 Not Found غیرمنتظره به کاربران که ناشی از فرآیند به‌روزرسانی است جلوگیری می‌کند.

این مکانیزم به نام _Mixed Version Proxy_ شناخته می‌شود.

## فعال‌سازی Mixed Version Proxy

مطمئن شوید که `UnknownVersionInteroperabilityProxy` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/)
هنگامی که {{< glossary_tooltip text="سرور API" term_id="kube-apiserver" >}} را شروع می‌کنید فعال است:

```shell
kube-apiserver \
--feature-gates=UnknownVersionInteroperabilityProxy=true \
# آرگومان‌های خط فرمان مورد نیاز برای این ویژگی
--peer-ca-file=<مسیر به گواهی CA سرور API> \
--proxy-client-cert-file=<مسیر به گواهی پروکسی تجمیع‌کننده> \
--proxy-client-key-file=<مسیر به کلید پروکسی تجمیع‌کننده> \
--requestheader-client-ca-file=<مسیر به گواهی CA تجمیع‌کننده> \
# می‌توان نام‌های مجاز requestheader را خالی گذاشت تا هر نام مشترکی را بپذیرد
--requestheader-allowed-names=<نام‌های معتبر برای بررسی گواهی پروکسی مشتری>,

# فلگ‌های اختیاری برای این ویژگی
--peer-advertise-ip=`IP این سرور API که باید توسط همتاها برای پروکسی کردن درخواست‌ها استفاده شود`
--peer-advertise-port=`پورت این سرور API که باید توسط همتاها برای پروکسی کردن درخواست‌ها استفاده شود`

# …و سایر فلگ‌ها به صورت معمول
```

### انتقال پروکسی و احراز هویت بین سرورهای API {#transport-and-authn}

* سرور API مبدا از
  [فلگ‌های احراز هویت مشتری سرور API موجود](/docs/tasks/extend-kubernetes/configure-aggregation-layer/#kubernetes-apiserver-client-authentication)
  `--proxy-client-cert-file` و `--proxy-client-key-file` برای ارائه هویتی که
  توسط همتای آن (سرور API مقصد) تأیید خواهد شد استفاده می‌کند. سرور API مقصد
  اتصال همتا را بر اساس تنظیماتی که با استفاده از آرگومان خط فرمان
  `--requestheader-client-ca-file` مشخص کرده‌اید تأیید می‌کند.

* برای احراز هویت گواهی‌های سرور مقصد، باید یک بسته گواهی CA را با مشخص کردن آرگومان خط فرمان
  `--peer-ca-file` به سرور API **مبدا** پیکربندی کنید.

### پیکربندی اتصال سرورهای API همتا

برای تنظیم مکان شبکه یک سرور API که همتاها برای پروکسی کردن درخواست‌ها از آن استفاده خواهند کرد، از
آرگومان‌های خط فرمان `--peer-advertise-ip` و `--peer-advertise-port` به سرور API استفاده کنید یا این فیلدها را در فایل پیکربندی سرور API مشخص کنید.
اگر این فلگ‌ها مشخص نشده باشند، همتاها از مقدار `--advertise-address` یا
`--bind-address` خط فرمان سرور API استفاده خواهند کرد.
اگر آن‌ها نیز تنظیم نشده باشند، اینترفیس پیش‌فرض میزبان استفاده می‌شود.

## پروکسی کردن نسخه‌های مختلط

وقتی پروکسی کردن نسخه‌های مختلط را فعال می‌کنید، [لایه تجمیع](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)
یک فیلتر ویژه بارگذاری می‌کند که موارد زیر را انجام می‌دهد:

* وقتی یک درخواست منبع به سرور API می‌رسد که نمی‌تواند آن API را سرو کند
  (یا به دلیل اینکه در نسخه‌ای قبل از معرفی API قرار دارد یا API روی سرور API خاموش است)
  سرور API تلاش می‌کند درخواست را به یک سرور API همتا که می‌تواند API درخواست شده را سرو کند ارسال کند.
  این کار با شناسایی گروه‌های API / نسخه‌ها / منابعی که سرور محلی نمی‌شناسد،
  و تلاش برای پروکسی کردن این درخواست‌ها به یک سرور API همتا که قادر به پردازش درخواست است انجام می‌شود.
* اگر سرور API همتا نتواند پاسخ دهد، سرور API _مبدا_ با خطای 503 ("Service Unavailable") پاسخ می‌دهد.

### نحوه کار در زیرساخت

وقتی یک سرور API یک درخواست منبع دریافت می‌کند، ابتدا بررسی می‌کند که کدام سرورهای API می‌توانند
منبع درخواست شده را سرو کنند. این بررسی با استفاده از داخلی
[`StorageVersion` API](/docs/reference/generated/kubernetes-api/v{{< skew currentVersion >}}/#storageversioncondition-v1alpha1-internal-apiserver-k8s-io) انجام می‌شود.

* اگر منبع برای سرور API که درخواست را دریافت کرده شناخته شده باشد
  (برای مثال، `GET /api/v1/pods/some-pod`)، درخواست به صورت محلی پردازش می‌شود.

* اگر هیچ شیء `StorageVersion` داخلی برای منبع درخواست شده یافت نشود
  (برای مثال، `GET /my-api/v1/my-resource`) و APIService تنظیم شده پروکسی کردن
  به یک سرور API توسعه‌ای را مشخص کند، آن پروکسی کردن طبق معمول انجام می‌شود
  [جریان](/docs/tasks/extend-kubernetes/configure-aggregation-layer/) برای APIهای توسعه.

* اگر یک شیء `StorageVersion` داخلی معتبر برای منبع درخواست شده یافت شود
  (برای مثال، `GET /batch/v1/jobs`) و سرور API تلاش کننده برای پردازش درخواست
  (سرور API _پردازش کننده_) API `batch` را غیرفعال داشته باشد، سپس سرور API _پردازش کننده_
  سرورهای API همتای که گروه / نسخه / منبع API مربوطه (`api/v1/batch` در این مورد) را سرو می‌کنند
  با استفاده از اطلاعات در شیء `StorageVersion` به دست آمده پیدا می‌کند.
  سرور API _پردازش کننده_ سپس درخواست را به یکی از سرورهای API همتا که از منبع درخواست شده آگاه است پروکسی می‌کند.

  * اگر هیچ همتایی برای آن گروه / نسخه / منبع API شناخته نشده باشد، سرور API پردازش کننده
    درخواست را به زنجیره پردازشگر خودش ارسال می‌کند که باید در نهایت با یک خطای 404 ("Not Found") پاسخ دهد.

  * اگر سرور API پردازش کننده یک سرور API همتا را شناسایی و انتخاب کرده باشد، اما آن همتا نتواند
    پاسخ دهد (به دلایلی مانند مشکلات اتصال شبکه، یا رقابت داده بین دریافت درخواست
    و یک کنترلر ثبت اطلاعات همتا در پلان کنترل)، سپس سرور API پردازش کننده با خطای 503 ("Service Unavailable") پاسخ می‌دهد.


