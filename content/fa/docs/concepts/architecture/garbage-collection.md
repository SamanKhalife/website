---
title: جمع‌آوری زباله
content_type: concept
weight: 70
---

<!-- overview -->
{{<glossary_definition term_id="garbage-collection" length="short">}} این
امکان را می‌دهد تا منابعی مانند موارد زیر پاکسازی شوند:

* [پادهای متوقف‌شده](/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection)
* [کارهای تکمیل‌شده](/docs/concepts/workloads/controllers/ttlafterfinished/)
* [اشیایی که مرجع مالک ندارند](#owners-dependents)
* [کانتینرها و تصاویر کانتینر استفاده‌نشده](#containers-images)
* [PersistentVolumes ایجاد شده دینامیکی با سیاست بازیابی StorageClass به صورت Delete](/docs/concepts/storage/persistent-volumes/#delete)
* [درخواست‌های امضای گواهینامه (CSR) کهنه یا منقضی‌شده](/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process)
* {{<glossary_tooltip text="نودهایی" term_id="node">}} که در سناریوهای زیر حذف شده‌اند:
  * در یک ابر زمانی که کلاستر از [مدیر کنترل ابری](/docs/concepts/architecture/cloud-controller/) استفاده می‌کند
  * در محیط‌های داخلی (on-premises) زمانی که کلاستر از افزونه‌ای مشابه با مدیر کنترل ابری استفاده می‌کند
* [اشیای اجاره نود](/docs/concepts/architecture/nodes/#heartbeats)

## مالکان و وابستگان {#owners-dependents}

بسیاری از اشیاء در Kubernetes از طریق [*مراجع مالک*](/docs/concepts/overview/working-with-objects/owners-dependents/) به یکدیگر متصل می‌شوند.
مراجع مالک به سطح کنترل می‌گویند که کدام اشیاء به دیگران وابسته هستند.
Kubernetes از مراجع مالک برای ارائه فرصت به سطح کنترل و سایر کلاینت‌های API برای پاکسازی منابع مرتبط قبل از حذف یک شیء استفاده می‌کند. در اکثر موارد، Kubernetes مراجع مالک را به طور خودکار مدیریت می‌کند.

مالکیت با مکانیزم [برچسب‌ها و انتخابگرها](/docs/concepts/overview/working-with-objects/labels/)
که برخی منابع نیز از آن استفاده می‌کنند، متفاوت است. برای مثال، یک
{{<glossary_tooltip text="سرویس" term_id="service">}} که اشیاء `EndpointSlice` ایجاد می‌کند را در نظر بگیرید. سرویس از *برچسب‌ها* برای اجازه به سطح کنترل جهت تعیین اینکه کدام اشیاء `EndpointSlice` برای آن سرویس استفاده می‌شوند، استفاده می‌کند. علاوه بر برچسب‌ها، هر `EndpointSlice` که به نمایندگی از یک سرویس مدیریت می‌شود دارای یک مرجع مالک نیز هست. مراجع مالک به بخش‌های مختلف Kubernetes کمک می‌کنند تا از دخالت در اشیایی که کنترل نمی‌کنند، جلوگیری کنند.

{{< note >}}
مراجع مالک بین نام‌فضاها به صورت طراحی‌شده مجاز نیستند.
وابستگان دارای نام‌فضا می‌توانند مالک‌های کلاستر-گسترده یا دارای نام‌فضا را مشخص کنند.
یک مالک دارای نام‌فضا **باید** در همان نام‌فضا که وابسته قرار دارد، موجود باشد.
اگر موجود نباشد، مرجع مالک به عنوان غایب در نظر گرفته می‌شود و وابسته
به محض تایید غیاب همه مالک‌ها، برای حذف در نظر گرفته می‌شود.

وابستگان کلاستر-گسترده تنها می‌توانند مالک‌های کلاستر-گسترده را مشخص کنند.
در v1.20+، اگر یک وابسته کلاستر-گسترده یک نوع دارای نام‌فضا را به عنوان مالک مشخص کند،
به عنوان دارای مرجع مالک غیرقابل حل در نظر گرفته می‌شود و قادر به جمع‌آوری زباله نیست.

در v1.20+، اگر جمع‌آوری زباله یک `ownerReference` نامعتبر بین نام‌فضاها یا یک وابسته کلاستر-گسترده با `ownerReference` مرجع‌دهنده به یک نوع دارای نام‌فضا را شناسایی کند، یک Event هشدار با دلیل `OwnerRefInvalidNamespace` و یک `involvedObject` از وابسته نامعتبر گزارش می‌شود.
می‌توانید برای این نوع Event با اجرای
`kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace` بررسی کنید.
{{< /note >}}

## حذف آبشاری {#cascading-deletion}

Kubernetes اشیایی را که دیگر مراجع مالک ندارند بررسی و حذف می‌کند، مانند پادهایی که پس از حذف یک ReplicaSet باقی می‌مانند. هنگامی که یک شیء را حذف می‌کنید، می‌توانید کنترل کنید که آیا Kubernetes وابستگان شیء را به طور خودکار حذف کند یا خیر، در فرآیندی که *حذف آبشاری* نامیده می‌شود. دو نوع حذف آبشاری وجود دارد:

* حذف آبشاری پیش‌زمینه
* حذف آبشاری پس‌زمینه

شما همچنین می‌توانید کنترل کنید که چگونه و چه زمانی جمع‌آوری زباله منابعی که مراجع مالک دارند را با استفاده از {{<glossary_tooltip text="finalizers" term_id="finalizer">}} Kubernetes حذف کند.

### حذف آبشاری پیش‌زمینه {#foreground-deletion}

در حذف آبشاری پیش‌زمینه، شیء مالک که در حال حذف هستید ابتدا وارد حالت *حذف در حال پیشرفت* می‌شود. در این حالت، موارد زیر برای شیء مالک اتفاق می‌افتد:

* سرور API Kubernetes فیلد `metadata.deletionTimestamp` شیء را به زمانی که شیء برای حذف علامت‌گذاری شده است، تنظیم می‌کند.
* سرور API Kubernetes همچنین فیلد `metadata.finalizers` را به
  `foregroundDeletion` تنظیم می‌کند.
* شیء تا زمانی که فرآیند حذف کامل شود، از طریق API Kubernetes قابل مشاهده باقی می‌ماند.

پس از اینکه شیء مالک وارد حالت حذف در حال پیشرفت شد، کنترلر وابستگان را حذف می‌کند. پس از حذف همه وابستگان، کنترلر شیء مالک را حذف می‌کند. در این مرحله، شیء دیگر در API Kubernetes قابل مشاهده نیست.

در طول حذف آبشاری پیش‌زمینه، تنها وابستگانی که فیلد `ownerReference.blockOwnerDeletion=true` دارند، مانع از حذف مالک می‌شوند.
برای اطلاعات بیشتر، [استفاده از حذف آبشاری پیش‌زمینه](/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion) را ببینید.
### حذف آبشاری در پس‌زمینه {#background-deletion}

در حذف آبشاری در پس‌زمینه، سرور API Kubernetes بلافاصله شیء مالک را حذف می‌کند و کنترلر اشیاء وابسته را در پس‌زمینه پاکسازی می‌کند. به طور پیش‌فرض، Kubernetes از حذف آبشاری در پس‌زمینه استفاده می‌کند مگر اینکه شما به صورت دستی حذف پیش‌زمینه‌ای را انتخاب کنید یا اشیاء وابسته را یتیم کنید.

برای اطلاعات بیشتر، به [استفاده از حذف آبشاری در پس‌زمینه](/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion) مراجعه کنید.

### وابستگان یتیم

وقتی Kubernetes شیء مالک را حذف می‌کند، اشیاء وابسته‌ای که باقی می‌مانند *یتیم* نامیده می‌شوند. به طور پیش‌فرض، Kubernetes اشیاء وابسته را حذف می‌کند. برای یادگیری چگونگی تغییر این رفتار، به [حذف اشیاء مالک و یتیم کردن وابستگان](/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy) مراجعه کنید.

## جمع‌آوری زباله کانتینرها و تصاویر استفاده‌نشده {#containers-images}

{{<glossary_tooltip text="kubelet" term_id="kubelet">}} جمع‌آوری زباله بر روی تصاویر استفاده‌نشده را هر دو دقیقه و بر روی کانتینرهای استفاده‌نشده را هر دقیقه انجام می‌دهد. باید از استفاده از ابزارهای جمع‌آوری زباله خارجی خودداری کنید، زیرا این ابزارها می‌توانند رفتار kubelet را مختل کرده و کانتینرهایی که باید وجود داشته باشند را حذف کنند.

برای تنظیم گزینه‌های جمع‌آوری زباله کانتینرها و تصاویر استفاده‌نشده، kubelet را با استفاده از یک [فایل پیکربندی](/docs/tasks/administer-cluster/kubelet-config-file/) تنظیم کنید و پارامترهای مربوط به جمع‌آوری زباله را با استفاده از نوع منبع [`KubeletConfiguration`](/docs/reference/config-api/kubelet-config.v1beta1/) تغییر دهید.

### چرخه حیات تصویر کانتینر

Kubernetes چرخه حیات همه تصاویر را از طریق *مدیر تصویر* خود که بخشی از kubelet است و با همکاری {{< glossary_tooltip text="cadvisor" term_id="cadvisor" >}} مدیریت می‌کند. kubelet محدودیت‌های استفاده از دیسک زیر را در هنگام تصمیم‌گیری برای جمع‌آوری زباله در نظر می‌گیرد:

* `HighThresholdPercent`
* `LowThresholdPercent`

استفاده از دیسک بالاتر از مقدار تنظیم شده `HighThresholdPercent` جمع‌آوری زباله را فعال می‌کند، که تصاویر را بر اساس آخرین زمان استفاده، از قدیمی‌ترین شروع به حذف می‌کند. kubelet تصاویر را حذف می‌کند تا استفاده از دیسک به مقدار `LowThresholdPercent` برسد.

#### جمع‌آوری زباله برای تصاویر کانتینر استفاده‌نشده {#image-maximum-age-gc}

{{< feature-state feature_gate_name="ImageMaximumGCAge" >}}

به عنوان یک ویژگی بتا، می‌توانید حداکثر زمانی را که یک تصویر محلی می‌تواند استفاده‌نشده بماند، بدون توجه به استفاده از دیسک مشخص کنید. این یک تنظیم kubelet است که برای هر نود پیکربندی می‌کنید.

برای تنظیم این ویژگی، `ImageMaximumGCAge` [feature gate](/docs/reference/command-line-tools-reference/feature-gates/) را برای kubelet فعال کنید و همچنین مقداری برای فیلد `imageMaximumGCAge` در فایل پیکربندی kubelet تعیین کنید.

مقدار به عنوان یک _مدت زمان_ Kubernetes مشخص می‌شود؛
واحدهای زمانی معتبر برای فیلد `imageMaximumGCAge` در فایل پیکربندی kubelet عبارتند از:
- "ns" برای نانوثانیه
- "us" یا "µs" برای میکروثانیه
- "ms" برای میلی‌ثانیه
- "s" برای ثانیه
- "m" برای دقیقه
- "h" برای ساعت

برای مثال، می‌توانید فیلد پیکربندی را به `12h45m` تنظیم کنید، که به معنای ۱۲ ساعت و ۴۵ دقیقه است.

{{< note >}}
این ویژگی استفاده از تصویر را در طول راه‌اندازی مجدد kubelet ردیابی نمی‌کند. اگر kubelet راه‌اندازی مجدد شود، سن تصویر ردیابی شده تنظیم مجدد می‌شود و باعث می‌شود kubelet منتظر مدت زمان کامل `imageMaximumGCAge` بماند تا تصاویر را بر اساس سن برای جمع‌آوری زباله واجد شرایط کند.
{{< /note>}}

### جمع‌آوری زباله کانتینرها {#container-image-garbage-collection}

kubelet جمع‌آوری زباله کانتینرهای استفاده‌نشده را بر اساس متغیرهای زیر انجام می‌دهد که شما می‌توانید آنها را تعریف کنید:

* `MinAge`: حداقل سنی که در آن kubelet می‌تواند یک کانتینر را جمع‌آوری زباله کند. با تنظیم به `0` غیرفعال کنید.
* `MaxPerPodContainer`: حداکثر تعداد کانتینرهای مرده‌ای که هر Pod می‌تواند داشته باشد. با تنظیم به کمتر از `0` غیرفعال کنید.
* `MaxContainers`: حداکثر تعداد کانتینرهای مرده‌ای که کلاستر می‌تواند داشته باشد. با تنظیم به کمتر از `0` غیرفعال کنید.

علاوه بر این متغیرها، kubelet کانتینرهای ناشناس و حذف شده را معمولاً با شروع از قدیمی‌ترین جمع‌آوری زباله می‌کند.

`MaxPerPodContainer` و `MaxContainers` ممکن است در شرایطی که نگهداری حداکثر تعداد کانتینرها برای هر Pod (`MaxPerPodContainer`) باعث می‌شود که کل تعداد کانتینرهای مرده جهانی (`MaxContainers`) بیشتر شود، با یکدیگر در تضاد باشند. در این شرایط، kubelet `MaxPerPodContainer` را تنظیم می‌کند تا تضاد را برطرف کند. در بدترین حالت، ممکن است `MaxPerPodContainer` به `1` کاهش یابد و قدیمی‌ترین کانتینرها حذف شوند. علاوه بر این، کانتینرهایی که متعلق به پادهایی هستند که حذف شده‌اند، زمانی که قدیمی‌تر از `MinAge` شوند، حذف می‌شوند.

{{<note>}}
kubelet تنها کانتینرهایی که مدیریت می‌کند را جمع‌آوری زباله می‌کند.
{{</note>}}

## پیکربندی جمع‌آوری زباله {#configuring-gc}

شما می‌توانید جمع‌آوری زباله منابع را با پیکربندی گزینه‌های خاص به کنترلرهای مدیریت‌کننده آن منابع تنظیم کنید. صفحات زیر به شما نشان می‌دهند که چگونه جمع‌آوری زباله را پیکربندی کنید:

* [پیکربندی حذف آبشاری اشیاء Kubernetes](/docs/tasks/administer-cluster/use-cascading-deletion/)
* [پیکربندی پاکسازی کارهای تکمیل‌شده](/docs/concepts/workloads/controllers/ttlafterfinished/)

## {{% heading "whatsnext" %}}

* درباره [مالکیت اشیاء Kubernetes](/docs/concepts/overview/working-with-objects/owners-dependents/) بیشتر بیاموزید.
* درباره [نهایی‌کننده‌های Kubernetes](/docs/concepts/overview/working-with-objects/finalizers/) بیشتر بیاموزید.
* درباره [کنترلر TTL](/docs/concepts/workloads/controllers/ttlafterfinished/) که کارهای تکمیل‌شده را پاکسازی می‌کند، بیاموزید.
