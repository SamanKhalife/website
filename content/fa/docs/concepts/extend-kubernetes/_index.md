---
title: توسعه Kubernetes
weight: 999 # این بخش باید در آخر بیاید
description: روش‌های مختلف برای تغییر رفتار خوشه Kubernetes شما.
reviewers:
- erictune
- lavalamp
- cheftako
- chenopis
feature:
  title: طراحی شده برای توسعه‌پذیری
  description: >
    افزودن ویژگی‌ها به خوشه Kubernetes بدون تغییر کد منبع اصلی.
content_type: concept
no_list: true
---

<!-- overview -->

Kubernetes بسیار قابل پیکربندی و توسعه‌پذیر است. در نتیجه، به ندرت نیاز به fork کردن یا ارسال پچ به کد پروژه Kubernetes وجود دارد.

این راهنما گزینه‌های سفارشی‌سازی یک خوشه Kubernetes را توصیف می‌کند. این راهنما به
{{< glossary_tooltip text="اپراتورهای خوشه" term_id="cluster-operator" >}} که می‌خواهند
نحوه تطبیق خوشه Kubernetes خود با نیازهای محیط کاری را بفهمند، هدف گرفته شده است. توسعه‌دهندگانی که
{{< glossary_tooltip text="توسعه‌دهندگان پلتفرم" term_id="platform-developer" >}} یا
{{< glossary_tooltip text="مشارکت‌کنندگان پروژه Kubernetes" term_id="contributor" >}} هستند نیز
آن را به عنوان مقدمه‌ای بر نقاط توسعه و الگوهای موجود، و مزایا و محدودیت‌های آن‌ها مفید خواهند یافت.

رویکردهای سفارشی‌سازی را می‌توان به طور کلی به [پیکربندی](#configuration)، که تنها شامل تغییر آرگومان‌های خط فرمان، فایل‌های پیکربندی محلی، یا منابع API است؛ و [توسعه‌ها](#extensions)، که شامل اجرای برنامه‌های اضافی، سرویس‌های شبکه اضافی، یا هر دو است، تقسیم کرد.
این سند در درجه اول درباره _توسعه‌ها_ است.

<!-- body -->

## پیکربندی

*فایل‌های پیکربندی* و *آرگومان‌های فرمان* در بخش [مرجع](/docs/reference/) مستند شده‌اند، با یک صفحه برای هر باینری:

* [`kube-apiserver`](/docs/reference/command-line-tools-reference/kube-apiserver/)
* [`kube-controller-manager`](/docs/reference/command-line-tools-reference/kube-controller-manager/)
* [`kube-scheduler`](/docs/reference/command-line-tools-reference/kube-scheduler/)
* [`kubelet`](/docs/reference/command-line-tools-reference/kubelet/)
* [`kube-proxy`](/docs/reference/command-line-tools-reference/kube-proxy/)

آرگومان‌های فرمان و فایل‌های پیکربندی ممکن است همیشه در یک سرویس میزبانی‌شده Kubernetes یا یک توزیع با نصب مدیریت‌شده قابل تغییر نباشند. وقتی که قابل تغییر باشند، معمولاً فقط توسط اپراتور خوشه قابل تغییر هستند. همچنین، این تنظیمات ممکن است در نسخه‌های آینده Kubernetes تغییر کنند، و تنظیم آن‌ها ممکن است نیاز به راه‌اندازی مجدد فرایندها داشته باشد. به این دلایل، باید تنها در مواقعی که هیچ گزینه دیگری وجود ندارد، استفاده شوند.

*APIهای سیاست داخلی*، مانند [ResourceQuota](/docs/concepts/policy/resource-quotas/)،
[NetworkPolicy](/docs/concepts/services-networking/network-policies/) و کنترل دسترسی مبتنی بر نقش
([RBAC](/docs/reference/access-authn-authz/rbac/))، APIهای داخلی Kubernetes هستند که تنظیمات سیاست به صورت اعلانی پیکربندی شده را ارائه می‌دهند.
APIها معمولاً حتی با سرویس‌های میزبانی‌شده Kubernetes و با نصب‌های مدیریت‌شده Kubernetes قابل استفاده هستند.
APIهای سیاست داخلی همان کنوانسیون‌های سایر منابع Kubernetes مانند Podها را دنبال می‌کنند.
وقتی از API سیاست استفاده می‌کنید که [پایدار](/docs/reference/using-api/#api-versioning) است، از
[سیاست پشتیبانی تعریف‌شده](/docs/reference/using-api/deprecation-policy/) مانند سایر APIهای Kubernetes بهره‌مند می‌شوید.
به این دلایل، APIهای سیاست نسبت به *فایل‌های پیکربندی* و *آرگومان‌های فرمان* در مواقع مناسب توصیه می‌شوند.

## توسعه‌ها

توسعه‌ها اجزای نرم‌افزاری هستند که Kubernetes را گسترش می‌دهند و به طور عمیق با آن ادغام می‌شوند.
آن‌ها را تطبیق می‌دهند تا از انواع جدید و سخت‌افزارهای جدید پشتیبانی کنند.

بسیاری از مدیران خوشه از یک نمونه میزبانی‌شده یا توزیعی از Kubernetes استفاده می‌کنند.
این خوشه‌ها با توسعه‌های از پیش نصب شده ارائه می‌شوند. در نتیجه، بیشتر کاربران Kubernetes
نیاز به نصب توسعه‌ها نخواهند داشت و حتی کاربران کمتری نیاز به نوشتن توسعه‌های جدید خواهند داشت.

### الگوهای توسعه

Kubernetes برای اتوماسیون توسط نوشتن برنامه‌های مشتری طراحی شده است. هر
برنامه‌ای که به API Kubernetes بخواند و/یا بنویسد می‌تواند اتوماسیون مفید ارائه دهد.
*اتوماسیون* می‌تواند در خوشه یا خارج از آن اجرا شود. با دنبال کردن راهنمایی‌های این مستند، می‌توانید اتوماسیون قوی و با دسترس‌پذیری بالا بنویسید.
اتوماسیون عموماً با هر خوشه Kubernetes، از جمله خوشه‌های میزبانی‌شده و نصب‌های مدیریت‌شده کار می‌کند.

یک الگوی خاص برای نوشتن برنامه‌های مشتری که با
Kubernetes خوب کار می‌کند وجود دارد که به آن {{< glossary_tooltip term_id="controller" text="کنترل‌کننده" >}}
می‌گویند. کنترل‌کننده‌ها معمولاً به `.spec` یک شیء می‌خوانند، احتمالاً اقداماتی انجام می‌دهند، و سپس
وضعیت شیء را به‌روزرسانی می‌کنند.

یک کنترل‌کننده یک مشتری API Kubernetes است. وقتی Kubernetes مشتری است و به یک سرویس از راه دور فراخوانی می‌کند،
Kubernetes این را *webhook* می‌نامد. سرویس از راه دور به عنوان
*backend webhook* شناخته می‌شود. همانند کنترل‌کننده‌های سفارشی، وب‌هوک‌ها نیز یک نقطه خرابی اضافه می‌کنند.

{{< note >}}
خارج از Kubernetes، اصطلاح "webhook" معمولاً به مکانیزمی برای اعلان‌های ناهمزمان اشاره دارد، جایی که فراخوانی وب‌هوک به عنوان یک اعلان یک‌طرفه به سیستم یا جزء دیگری عمل می‌کند. در اکوسیستم Kubernetes، حتی فراخوانی‌های همگام HTTP اغلب به عنوان "وب‌هوک" توصیف می‌شوند.
{{< /note >}}

در مدل webhook، Kubernetes یک درخواست شبکه‌ای به یک سرویس از راه دور می‌فرستد.
با مدل جایگزین *پلاگین باینری*، Kubernetes یک باینری (برنامه) را اجرا می‌کند.
پلاگین‌های باینری توسط kubelet استفاده می‌شوند (برای مثال، [پلاگین‌های ذخیره‌سازی CSI](https://kubernetes-csi.github.io/docs/)
و [پلاگین‌های شبکه CNI](/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/))،
و توسط kubectl (نگاه کنید به [توسعه kubectl با پلاگین‌ها](/docs/tasks/extend-kubectl/kubectl-plugins/)).

### نقاط توسعه

این نمودار نقاط توسعه در یک خوشه Kubernetes و
مشتری‌هایی که به آن دسترسی دارند را نشان می‌دهد.

<!-- image source: https://docs.google.com/drawings/d/1k2YdJgNTtNfW7_A8moIIkij-DmVgEhNrn3y2OODwqQQ/view -->

{{< figure src="/docs/concepts/extend-kubernetes/extension-points.png"
    alt="نمایش نمادین هفت نقطه توسعه شماره‌گذاری شده برای Kubernetes"
    class="diagram-large" caption="نقاط توسعه Kubernetes" >}}

#### کلید نمودار

1. کاربران اغلب با استفاده از `kubectl` با API Kubernetes تعامل دارند. [پلاگین‌ها](#client-extensions)
   رفتار مشتریان را سفارشی می‌کنند. پلاگین‌های عمومی وجود دارند که می‌توانند به مشتری‌های مختلف اعمال شوند،
   و همچنین روش‌های خاص برای توسعه `kubectl`.

1. سرور API تمام درخواست‌ها را مدیریت می‌کند. چندین نوع از نقاط توسعه در سرور API اجازه می‌دهند
   درخواست‌ها را احراز هویت کنند، یا بر اساس محتوای آن‌ها آن‌ها را مسدود کنند، محتوا را ویرایش کنند، و
   حذف را مدیریت کنند. این‌ها در بخش [توسعه‌های دسترسی API](#api-access-extensions) توضیح داده شده‌اند.

1. سرور API انواع مختلفی از *منابع* را خدمت می‌دهد. *انواع منابع داخلی*، مانند
   `pods`، توسط پروژه Kubernetes تعریف شده‌اند و قابل تغییر نیستند.
   برای یادگیری درباره توسعه API Kubernetes به [توسعه‌های API](#api-extensions) مراجعه کنید.

1. زمان‌بند Kubernetes [تصمیم می‌گیرد](/docs/concepts/scheduling-eviction/assign-pod-node/)
   که کدام گره‌ها را به پادها اختصاص دهد. روش‌های مختلفی برای توسعه زمان‌بندی وجود دارد که
   در بخش [توسعه‌های زمان‌بندی](#scheduling-extensions) توضیح داده شده‌اند.

1. بسیاری از رفتارهای Kubernetes توسط برنامه‌هایی به نام
   {{< glossary_tooltip term_id="controller" text="کنترل‌کننده" >}} که
   مشتری‌های سرور API هستند، پیاده‌سازی شده‌اند. کنترل‌کننده‌ها اغلب با منابع سفارشی استفاده می‌شوند.
   برای یادگیری بیشتر، [ترکیب APIهای جدید با اتوماسیون](#combining-new-apis-with-automation) و
   [تغییر منابع داخلی](#changing-built-in-resources) را مطالعه کنید.

1. kubelet روی سرورها (گره‌ها) اجرا می‌شود، و کمک می‌کند پادها مانند سرورهای مجازی با IPهای خود در
   شبکه خوشه ظاهر شوند. [پلاگین‌های شبکه](#network-plugins) اجازه می‌دهند تا پیاده‌سازی‌های مختلفی از
   شبکه پادها استفاده شود.

1. شما می‌توانید از [پلاگین‌های دستگاه](#device-plugins) برای ادغام سخت‌افزار سفارشی یا سایر
   امکانات محلی خاص گره استفاده کنید، و این‌ها را برای پادهایی که در خوشه شما اجرا می‌شوند در دسترس قرار دهید. kubelet
   شامل پشتیبانی برای کار با پلاگین‌های دستگاه است.

   kubelet همچنین mount و unmount
   {{< glossary_tooltip text="volume" term_id="volume" >}} برای پادها و کانتینرهای آن‌ها را انجام می‌دهد.
   شما می‌توانید از [پلاگین‌های ذخیره‌سازی](#storage-plugins) برای افزودن پشتیبانی از انواع جدیدی
   از ذخیره‌سازی و سایر انواع volume استفاده کنید.
#### نمودار جریان انتخاب نقطه توسعه {#extension-flowchart}

اگر نمی‌دانید از کجا شروع کنید، این نمودار جریان می‌تواند به شما کمک کند. توجه داشته باشید که برخی از راه‌حل‌ها ممکن است شامل چندین نوع توسعه باشند.

<!-- image source for flowchart: https://docs.google.com/drawings/d/1sdviU6lDz4BpnzJNHfNpQrqI9F19QZ07KnhnxVrp2yg/edit -->

{{< figure src="/docs/concepts/extend-kubernetes/flowchart.svg"
    alt="نمودار جریان با سوالاتی درباره موارد استفاده و راهنمایی برای پیاده‌سازان. دایره‌های سبز بله را نشان می‌دهند؛ دایره‌های قرمز خیر را نشان می‌دهند."
    class="diagram-large" caption="راهنمای نمودار جریان برای انتخاب یک رویکرد توسعه" >}}

---

## توسعه‌های مشتری

پلاگین‌ها برای kubectl باینری‌های جداگانه‌ای هستند که رفتار زیر فرمان‌های خاص را اضافه یا جایگزین می‌کنند.
ابزار `kubectl` همچنین می‌تواند با [پلاگین‌های اعتبارنامه](/docs/reference/access-authn-authz/authentication/#client-go-credential-plugins) نیز ادغام شود.
این توسعه‌ها فقط محیط محلی یک کاربر خاص را تحت تأثیر قرار می‌دهند و بنابراین نمی‌توانند سیاست‌های سایت گسترده را اجرا کنند.

اگر می‌خواهید ابزار `kubectl` را توسعه دهید، [توسعه kubectl با پلاگین‌ها](/docs/tasks/extend-kubectl/kubectl-plugins/) را بخوانید.

## توسعه‌های API

### تعریف منابع سفارشی

در نظر بگیرید یک _منبع سفارشی_ به Kubernetes اضافه کنید اگر می‌خواهید کنترل‌کننده‌های جدید، اشیاء پیکربندی برنامه یا دیگر APIهای اعلانی را تعریف کنید و آن‌ها را با استفاده از ابزارهای Kubernetes مانند `kubectl` مدیریت کنید.

برای اطلاعات بیشتر درباره منابع سفارشی، راهنمای مفهومی [منابع سفارشی](/docs/concepts/extend-kubernetes/api-extension/custom-resources/) را ببینید.

### لایه تجمع API

می‌توانید از [لایه تجمع API](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/) Kubernetes برای ادغام API Kubernetes با خدمات اضافی مانند [متریک‌ها](/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/) استفاده کنید.

### ترکیب APIهای جدید با اتوماسیون

ترکیبی از API منبع سفارشی و یک حلقه کنترل به عنوان الگوی
{{< glossary_tooltip term_id="controller" text="کنترل‌کننده" >}} شناخته می‌شود. اگر کنترل‌کننده شما جایگزین یک اپراتور انسانی است که زیرساخت را بر اساس حالت مطلوب مستقر می‌کند، آنگاه کنترل‌کننده ممکن است همچنین الگوی
{{< glossary_tooltip text="الگوی اپراتور" term_id="operator-pattern" >}} را دنبال کند.
الگوی اپراتور برای مدیریت برنامه‌های خاص استفاده می‌شود؛ معمولاً این‌ها برنامه‌هایی هستند که حالت را نگهداری می‌کنند و نیاز به مراقبت در نحوه مدیریت آن‌ها دارند.

همچنین می‌توانید APIها و حلقه‌های کنترلی خود را که منابع دیگر مانند ذخیره‌سازی را مدیریت می‌کنند، یا برای تعریف سیاست‌ها (مانند محدودیت‌های کنترل دسترسی) بنویسید.

### تغییر منابع داخلی

وقتی API Kubernetes را با افزودن منابع سفارشی توسعه می‌دهید، منابع اضافه شده همیشه به گروه‌های API جدید تعلق دارند. شما نمی‌توانید گروه‌های API موجود را جایگزین یا تغییر دهید.
افزودن یک API به طور مستقیم به شما اجازه نمی‌دهد تا رفتار APIهای موجود (مانند Pods) را تحت تأثیر قرار دهید، در حالی که
_توسعه‌های دسترسی API_ این امکان را فراهم می‌کنند.

## توسعه‌های دسترسی API

وقتی یک درخواست به سرور API Kubernetes می‌رسد، ابتدا _احراز هویت_ می‌شود، سپس _مجوز داده می‌شود_،
و سپس تحت انواع مختلف _کنترل پذیرش_ قرار می‌گیرد (برخی درخواست‌ها در واقع احراز هویت نمی‌شوند و به طور ویژه‌ای مدیریت می‌شوند). برای اطلاعات بیشتر در مورد این جریان، به
[کنترل دسترسی به API Kubernetes](/docs/concepts/security/controlling-access/) مراجعه کنید.

هر یک از مراحل در جریان احراز هویت / مجوز Kubernetes نقاط توسعه‌ای را ارائه می‌دهند.

### احراز هویت

[احراز هویت](/docs/reference/access-authn-authz/authentication/) هدرها یا گواهی‌نامه‌های موجود در تمام درخواست‌ها را به یک نام کاربری برای مشتری که درخواست را انجام می‌دهد، نقشه‌برداری می‌کند.

Kubernetes چندین روش احراز هویت داخلی را پشتیبانی می‌کند. همچنین می‌تواند پشت یک پروکسی احراز هویت قرار بگیرد و می‌تواند یک توکن را از یک هدر `Authorization:` به یک سرویس از راه دور برای تأیید اعتبار ارسال کند (یک
[وب‌هوک احراز هویت](/docs/reference/access-authn-authz/authentication/#webhook-token-authentication))
اگر این‌ها نیازهای شما را برآورده نکنند.

### مجوز

[مجوز](/docs/reference/access-authn-authz/authorization/) تعیین می‌کند که آیا کاربران خاص می‌توانند بخوانند، بنویسند و عملیات‌های دیگر روی منابع API انجام دهند. این کار در سطح کل منابع انجام می‌شود -- تبعیض براساس فیلدهای شیء دلخواه اعمال نمی‌شود.

اگر گزینه‌های مجوز داخلی نیازهای شما را برآورده نمی‌کنند، یک
[وب‌هوک مجوز](/docs/reference/access-authn-authz/webhook/)
به شما اجازه می‌دهد تا کدی سفارشی که تصمیم مجوز را می‌گیرد، فراخوانی کنید.

### کنترل پذیرش پویا

بعد از اینکه یک درخواست مجوز داده شد، اگر یک عملیات نوشتن باشد، همچنین از مراحل
[کنترل پذیرش](/docs/reference/access-authn-authz/admission-controllers/) عبور می‌کند.
علاوه بر مراحل داخلی، چندین توسعه نیز وجود دارد:

* [وب‌هوک سیاست تصویر](/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook)
  محدود می‌کند که چه تصاویری می‌توانند در کانتینرها اجرا شوند.
* برای گرفتن تصمیمات کنترل پذیرش دلخواه، می‌توان از یک
  [وب‌هوک پذیرش](/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks)
  عمومی استفاده کرد. وب‌هوک‌های پذیرش می‌توانند ایجادها یا به‌روزرسانی‌ها را رد کنند.
  برخی وب‌هوک‌های پذیرش داده‌های درخواست ورودی را قبل از اینکه بیشتر توسط Kubernetes پردازش شوند، اصلاح می‌کنند.

## توسعه‌های زیرساخت

### پلاگین‌های دستگاه

_پلاگین‌های دستگاه_ به یک گره اجازه می‌دهند تا منابع جدید Node را (علاوه بر موارد داخلی مانند cpu و حافظه) از طریق یک
[پلاگین دستگاه](/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/) کشف کنند.

### پلاگین‌های ذخیره‌سازی

{{< glossary_tooltip text="رابط ذخیره‌سازی کانتینر" term_id="csi" >}} (CSI) پلاگین‌ها روشی برای توسعه Kubernetes با پشتیبانی از انواع جدید volumes فراهم می‌کنند. volumes می‌توانند توسط ذخیره‌سازی خارجی پایدار پشتیبانی شوند، یا ذخیره‌سازی موقتی فراهم کنند، یا ممکن است یک رابط فقط خواندنی به اطلاعات با استفاده از یک پارادایم فایل سیستم ارائه دهند.

Kubernetes همچنین از پلاگین‌های [FlexVolume](/docs/concepts/storage/volumes/#flexvolume) پشتیبانی می‌کند،
که از Kubernetes v1.23 (به نفع CSI) منسوخ شده‌اند.

پلاگین‌های FlexVolume به کاربران اجازه می‌دهند تا نوع‌های volumeی را که به صورت بومی توسط Kubernetes پشتیبانی نمی‌شوند، mount کنند. وقتی شما یک Pod را اجرا می‌کنید که به ذخیره‌سازی FlexVolume متکی است، kubelet یک پلاگین باینری را برای mount کردن volume فراخوانی می‌کند.
پیشنهاد طراحی [FlexVolume](https://git.k8s.io/design-proposals-archive/storage/flexvolume-deployment.md)
بایگانی شده جزئیات بیشتری در این روش ارائه می‌دهد.

[پرسش‌های متداول پلاگین Volume Kubernetes برای فروشندگان ذخیره‌سازی](https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md#kubernetes-volume-plugin-faq-for-storage-vendors)
شامل اطلاعات عمومی در مورد پلاگین‌های ذخیره‌سازی است.

### پلاگین‌های شبکه

خوشه Kubernetes شما به یک _پلاگین شبکه_ نیاز دارد تا یک شبکه Pod کارآمد داشته باشد
و از سایر جنبه‌های مدل شبکه Kubernetes پشتیبانی کند.

[پلاگین‌های شبکه](/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)
به Kubernetes اجازه می‌دهند تا با توپولوژی‌ها و فناوری‌های شبکه مختلف کار کند.

### پلاگین‌های تأمین اعتبار تصویر kubelet

{{< feature-state for_k8s_version="v1.26" state="stable" >}}
پلاگین‌های تأمین اعتبار تصویر kubelet پلاگین‌هایی برای kubelet هستند که به صورت پویا اعتبارنامه‌های رجیستری تصویر را بازیابی می‌کنند. اعتبارنامه‌ها سپس هنگام کشیدن تصاویر از رجیستری‌های تصویر کانتینر که با پیکربندی مطابقت دارند، استفاده می‌شوند.

پلاگین‌ها می‌توانند با خدمات خارجی ارتباط برقرار کنند یا از فایل‌های محلی برای به‌دست آوردن اعتبارنامه‌ها استفاده کنند. به این ترتیب،
kubelet نیازی به داشتن اعتبارنامه‌های ثابت برای هر رجیستری ندارد و می‌تواند از روش‌ها و پروتکل‌های مختلف احراز هویت پشتیبانی کند.

برای جزئیات پیکربندی پلاگین، [پیکربندی یک پلاگین تأمین اعتبار تصویر kubelet](/docs/tasks/administer-cluster/kubelet-credential-provider/) را ببینید.

## توسعه‌های زمان‌بندی

زمان‌بند یک نوع خاص از کنترل‌کننده است که پادها را نظارت می‌کند و
پادها را به گره‌ها اختصاص می‌دهد. زمان‌بند پیش‌فرض می‌تواند به طور کامل جایگزین شود، در حالی که
ادامه استفاده از سایر اجزای Kubernetes، یا
[چندین زمان‌بند](/docs/tasks/extend-kubernetes/configure-multiple-schedulers/)
می‌توانند همزمان اجرا شوند.

این یک تعهد بزرگ است، و تقریباً تمام کاربران Kubernetes متوجه می‌شوند که
نیازی به اصلاح زمان‌بند ندارند.

شما می‌توانید کنترل کنید که کدام [پلاگین‌های زمان‌بندی](/docs/reference/scheduling/config/#scheduling-plugins)
فعال هستند، یا مجموعه‌ای از پلاگین‌ها را با [پروفایل‌های زمان‌بندی](/docs/reference/scheduling/config/#multiple-profiles) مختلف نام‌گذاری شده مرتبط کنید.
همچنین می‌توانید پلاگین خود را بنویسید که با یک یا چند نقطه توسعه زمان‌بند kube-scheduler
[نقاط توسعه](/docs/concepts/scheduling-eviction/scheduling-framework/#extension-points) ادغام می‌شود.

در نهایت، جزء `kube-scheduler` داخلی از یک
[وب‌هوک](https://git.k8s.io/design-proposals-archive/scheduling/scheduler_extender.md)
پشتیبانی می‌کند که به یک بک‌اند HTTP از راه دور (توسعه‌دهنده زمان‌بند) اجازه می‌دهد تا فیلتر و / یا اولویت‌بندی
گره‌هایی که kube-scheduler برای یک پاد انتخاب می‌کند را انجام دهد.

{{< note >}}
شما فقط می‌توانید فیلتر گره و
اولویت‌بندی گره با یک وب‌هوک توسعه‌دهنده زمان‌بند را تحت تأثیر قرار دهید؛ سایر نقاط توسعه از طریق ادغام وب‌هوک در دسترس نیستند.
{{< /note >}}

## {{% heading "whatsnext" %}}

* اطلاعات بیشتری درباره توسعه‌های زیرساخت کسب کنید
  * [پلاگین‌های دستگاه](/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/)
  * [پلاگین‌های شبکه](/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/)
  * CSI [پلاگین‌های ذخیره‌سازی](https://kubernetes-csi.github.io/docs/)
* درباره [پلاگین‌های kubectl](/docs/tasks/extend-kubectl/kubectl-plugins/) بیشتر بدانید
* اطلاعات بیشتری درباره [منابع سفارشی](/docs/concepts/extend-kubernetes/api-extension/custom-resources/) کسب کنید
* درباره [سرورهای توسعه API](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/) بیشتر بدانید
* درباره [کنترل پذیرش پویا](/docs/reference/access-authn-authz/extensible-admission-controllers/) بیشتر بدانید
* درباره [الگوی اپراتور](/docs/concepts/extend-kubernetes/operator/) بیشتر بدانید
