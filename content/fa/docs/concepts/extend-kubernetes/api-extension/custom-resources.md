---
title: منابع سفارشی
reviewers:
- enisoc
- deads2k
api_metadata:
- apiVersion: "apiextensions.k8s.io/v1"
  kind: "CustomResourceDefinition"
content_type: concept
weight: 10
---

<!-- overview -->

*منابع سفارشی* گسترش‌هایی از API Kubernetes هستند. این صفحه در مورد زمانی که باید یک منبع سفارشی به خوشه Kubernetes خود اضافه کنید و زمان استفاده از یک سرویس مستقل بحث می‌کند. دو روش اضافه کردن منابع سفارشی و چگونگی انتخاب بین آن‌ها توضیح داده شده است.

<!-- body -->
## منابع سفارشی

یک *منبع* یک نقطه پایانی در [API Kubernetes](/docs/concepts/overview/kubernetes-api/) است که مجموعه‌ای از {{< glossary_tooltip text="اشیاء API" term_id="object" >}} از یک نوع خاص را ذخیره می‌کند؛ به عنوان مثال، منبع *پادها* داخلی یک مجموعه از اشیاء پاد را شامل می‌شود.

یک *منبع سفارشی* گسترشی از API Kubernetes است که به طور لازم در نصب پیش‌فرض Kubernetes موجود نیست. این نمایانگر یک سفارش‌دهی از یک نصب خاص Kubernetes است. با این حال، بسیاری از توابع اصلی Kubernetes اکنون با استفاده از منابع سفارشی ساخته شده‌اند که Kubernetes را به صورت ماژولارتر می‌کنند.

منابع سفارشی می‌توانند در یک خوشه اجرایی از طریق ثبت پویا ظاهر و ناپدید شوند، و مدیران خوشه می‌توانند منابع سفارشی را به صورت مستقل از خوشه به روزرسانی کنند. هنگامی که یک منبع سفارشی نصب شود، کاربران می‌توانند اشیاء آن را با استفاده از {{< glossary_tooltip text="kubectl" term_id="kubectl" >}} ایجاد و دسترسی پیدا کنند، به همان شکلی که برای منابع داخلی مانند *پادها* عمل می‌کنند.

## کنترل‌کننده‌های سفارشی

به تنهایی، منابع سفارشی به شما اجازه می‌دهند تا داده‌های ساختارمند را ذخیره و بازیابی کنید. هنگامی که یک منبع سفارشی را با یک *کنترل‌کننده سفارشی* ترکیب می‌کنید، منابع سفارشی یک API *اعلامی* حقیقی فراهم می‌کنند.

API اعلامی Kubernetes یک جدایی از مسئولیت را اعمال می‌کند. شما وضعیت مطلوب منبع خود را اعلام می‌کنید. کنترل‌کننده Kubernetes وضعیت فعلی اشیاء Kubernetes را با وضعیت مطلوب اعلام شده شما همگام می‌سازد. این در مقابل API امری است که به شما می‌گوید که به یک سرور چه کاری انجام دهید.

شما می‌توانید یک کنترل‌کننده سفارشی را در یک خوشه اجرایی انتشار دهید و به روزرسانی کنید، به طور مستقل از چرخه عمر خوشه. کنترل‌کننده‌های سفارشی می‌توانند با هر نوع منبع کار کنند، اما وقتی با منابع سفارشی ترکیب می‌شوند، به ویژه موثر هستند. الگوی [اپراتور](/docs/concepts/extend-kubernetes/operator/) منابع سفارشی و کنترل‌کننده‌های سفارشی را ترکیب می‌کند. شما می‌توانید از کنترل‌کننده‌های سفارشی برای کد گذاری دانش دامنه برنامه‌های خاص را به یک گسترش از API Kubernetes استفاده کنید.

## آیا باید یک منبع سفارشی را به خوشه Kubernetes خود اضافه کنم؟

هنگامی که یک API جدید ایجاد می‌کنید، در نظر داشته باشید که آیا باید
[API خود را با API‌های خوشه Kubernetes تجمیع کنید](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)
یا به API خود اجازه دهید که مستقل باشد.

| در نظر بگیرید تجمیع API اگر: | ترجیح دهید که یک API مستقل داشته باشید اگر: |
| ---------------------------- | ---------------------------- |
| API شما [اعلامی است](#api‌های-اعلامی). | پشتیبانی از API درخواستی نیاز نیست. |
| می‌خواهید نوع‌های جدید خود را با استفاده از `kubectl` خوانا و قابل نوشتن کنید. | پشتیبانی از `kubectl` لازم نیست. |
| می‌خواهید نوع‌های جدید خود را در رابط کاربری Kubernetes، مانند داشبورد، در کنار انواع داخلی مشاهده کنید. | پشتیبانی از رابط کاربری Kubernetes لازم نیست. |
| در حال توسعه یک API جدید هستید. | برنامه‌ای که API شما را خدمت می‌دهد و خوب کار می‌کند، در حال حاضر موجود است. |
| حاضرید که محدودیت فرمتی که Kubernetes بر روی مسیرهای منابع REST مانند گروه‌های API و فضاهای نامه‌ها اعمال می‌کند، را بپذیرید. (مشاهده [مرور کلی API](/docs/concepts/overview/kubernetes-api/).) | نیاز دارید که مسیرهای REST خاصی را برای سازگاری با API RESTی تعریف شده از پیش داشته باشید. |
| منابع شما به طور طبیعی به یک خوشه یا فضاهای یک خوشه محدود هستند. | منابع محدود به خوشه یا فضاهای فضا به خوبی جایگذاری نیستند. شما نیاز به کنترل بیشتر بر روی جزئیات مسیر منبع دارید. |
| می‌خواهید از قابلیت‌های پشتیبانی از [API Kubernetes](#ویژگی‌های-مشترک) استفاده کنید. | شما به این ویژگی‌ها نیاز ندارید. |

### API‌های اعلامی

در یک API اعلامی، به طور معمول:

- API شما از تعداد کمی اشیاء نسبتاً کمی تشکیل شده است.
- اشیاء پیکربندی برنامه‌ها یا زیرساخت‌ها را تعریف می‌کنند.
- اشیاء به طور نسبتاً اغلب به‌روزرسانی می‌شوند.
- انسان‌ها اغلب نیاز به خواندن و نوشتن اشیاء دارند.
- عملیات اصلی بر روی اشیاء CRUD-y است (ایجاد، خواندن، به‌روزرسانی و حذف).
- معاملات در اشیاء لازم نیست: API وضعیت مطلوب را نشان می‌دهد، نه وضعیت دقیق.

API‌های امری اعلامی نیستند.
نشانه‌هایی که ممکن است API شما اعلامی نباشد عبارتند از:

- مشتری می‌گوید "این کار را انجام دهید"، و سپس وقتی کار تمام شود، یک پاسخ همگام برمی‌گردد.
- مشتری می‌گوید "این کار را انجام دهید"، و سپس یک شناسه عملیاتی را به عنوان جواب دریافت می‌کند، و باید یک شیء جداگانه عملیاتی را برای تعیین اتمام درخواست بررسی کند.
- درباره تماس‌های فراخوانی راه‌اندازی شده‌اند (RPCs).
- ذخیره مستقیم حجم بزرگی از داده؛ به عنوان مثال،> چند KB در هر شیء، یا> 1000s از اشیاء.
- نیاز به دسترسی پهنای باند بالا (10s از درخواستها در ثانیه پایدار).
- ذخیره داده‌های کاربران نهایی (مانند تصاویر، PII، و غیره) یا دیگر داده‌های بزرگ‌مقیاس که توسط برنامه‌ها پردازش می‌شود.
- عملیات طبیعی بر روی اشیاء CRUD-y نیست.
- API به راحتی به عنوان اشیاء نمی‌تواند مدل‌سازی شود.
- شما انتخاب می‌کنید که عملیات در انتظار را با یک شناسه عملیات یا یک شیء عملیات نشان دهید.

## آیا از ConfigMap یا منبع سفارشی استفاده کنم؟

از ConfigMap استفاده کنید اگر هرکدام از موارد زیر را دارید:

* یک فرمت فایل پیکربندی موجود و خوب مستند شده، مانند `mysql.cnf` یا `pom.xml`.
* می‌خواهید کل پیکربندی را در یک کلید از ConfigMap قرار دهید.
* استفاده اصلی از فایل پیکربندی برای یک برنامه در حال اجرا در پاد خوشه خود برای مصرف فایل برای تنظیم خود است.
* مصرف‌کنندگان فایل ترجیح می‌دهند که از طریق فایل در یک پاد یا متغیر محیطی در پاد، به جای API Kubernetes مصرف کنند.
* می‌خواهید به‌روزرسانی‌های پیکربندی از طریق Deployment، و غیره، هنگام به‌روزرسانی فایل صورت گیرد.

{{< note >}}
از یک {{< glossary_tooltip text="Secret" term_id="secret" >}} برای داده‌های حساس استفاده کنید که مشابه یک ConfigMap است، اما ایمن‌تر است.
{{< /note >}}

از یک منبع سفارشی (CRD یا API تجمیع شده) استفاده کنید اگر اکثر موارد زیر را داشته باشید:

* می‌خواهید از کتابخانه‌های مشتری Kubernetes و CLI‌ها برای ایجاد و به‌روزرسانی منبع جدید استفاده کنید.
* از پشتیبانی سطح بالایی از `kubectl` استفاده کنید؛ به عنوان مثال، `kubectl get my-object object-name`.
* می‌خواهید اتوماسیون جدیدی بنویسید که برای به‌روزرسانی‌های اشیاء به روزرسانی شود، و سپس CRUD اشیاء دیگر یا برعکس.
* می‌خواهید اتوماسیونی بنویسید که به به‌روزرسانی اشیاء بپردازد.
* از کنونشن‌های API Kubernetes مانند `.spec`، `.status`، و `.metadata` استفاده کنید.
* می‌خواهید اشیاء را به عنوان یک انتزاع بر روی مجموعه‌ای از منابع کنترل شده یا خلاصه‌ای از منابع دیگر استفاده کنید.

## اضافه کردن منابع سفارشی

Kubernetes دو روش برای اضافه کردن منابع سفارشی به خوشه شما فراهم می‌کند:

- CRDها ساده هستند و می‌توانند بدون هیچ برنامه‌نویسی‌ای ایجاد شوند.
- [تجمیع API](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)
  نیاز به برنامه‌نویسی دارد، اما اجازه کنترل بیشتری روی رفتارهای API مانند نحوه ذخیره‌سازی داده و تبدیل بین نسخه‌های API را می‌دهد.

Kubernetes این دو گزینه را برای پاسخگویی به نیازهای کاربران مختلف ارائه داده است، به طوری که هیچ‌کدام از راحتی
استفاده و نهایت انعطاف را آسیب نمی‌بیند.

API‌های تجمیع شده، API‌های فرعی هستند که در پشت API‌های اصلی نشسته‌اند که به عنوان یک پروکسی عمل می‌کند. این ترتیب به نام
[تجمیع API](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/)
(AA) است.
برای کاربران، API Kubernetes به طور گسترده‌تر به نظر می‌رسد.

CRDها به کاربران امکان می‌دهند تا انواع جدیدی از منابع را ایجاد کنند بدون افزودن یک سرور API دیگر. شما نیازی به درک API Aggregation برای استفاده از CRDها ندارید.

به طور ناشی از نصب شدن آنها، منابع جدید به عنوان منابع سفارشی شناخته می‌شوند تا از منابع Kubernetes داخلی (مانند pods) متمایز شوند.

{{< note >}}
اجتناب از استفاده از یک منبع سفارشی به عنوان ذخیره سازی داده برنامه، کاربر نهایی یا داده‌های نظارتی:
طرح‌های معماری که داده برنامه را در API Kubernetes ذخیره می‌کنند، معمولاً نشان دهنده یک طراحی است که به طور ناگهانی با هم مرتبط است.

در اصطلاح معماری [نیتیو ابر](https://www.cncf.io/about/faq/#what-is-cloud-native)، معماری‌های برنامه‌ای از اتصال کم‌پیوند بین اجزا حمایت می‌کنند. اگر بخشی از بار کاری شما نیاز به یک سرویس پشتیبان برای عملکرد عادی خود داشته باشد، این سرویس پشتیبان را به عنوان یک جزء اجرا کنید یا آن را به عنوان یک سرویس خارجی مصرف کنید.
این طور، بار کاری شما برای عملکرد عادی خود به API Kubernetes نیاز ندارد.
{{< /note >}}

## تعریف منابع سفارشی (CustomResourceDefinitions)

منبع API [CustomResourceDefinition](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/)
به شما امکان می‌دهد تا منابع سفارشی خود را تعریف کنید.
تعریف یک شیء CRD، یک منبع سفارشی جدید با یک نام و طرحی که شما مشخص می‌کنید، ایجاد می‌کند.
API Kubernetes خدمات و مدیریت ذخیره‌سازی منبع سفارشی شما را انجام می‌دهد.
نام یک شیء CRD باید یک نام زیردامنه DNS معتبر باشد
([DNS subdomain name](/docs/concepts/overview/working-with-objects/names#dns-subdomain-names)).

این باعث می‌شود که شما از نوشتن سرور API خود برای مدیریت منبع سفارشی خود بی‌نیاز باشید،
اما ماهیت کلی اجرای پیاده‌سازی به معنای کمتر از انعطاف است که با
[تجمیع سرور API](#api-server-aggregation)
می‌تواند به انعطاف پذیری بیشتری دست یابد.

برای دیدن مثال کنترل کننده سفارشی به
[مثال کنترل کننده سفارشی](https://github.com/kubernetes/sample-controller)
مراجعه کنید.

## تجمیع سرور API (API server aggregation)

معمولاً هر منبع در API Kubernetes نیاز به کدی دارد که درخواست‌های REST را پردازش کرده و مدیریت
ذخیره‌سازی ماندگاری اشیاء را انجام دهد. سرور API اصلی Kubernetes منابع تعبیه شده مانند
*pods* و *services* را پردازش می‌کند و همچنین به طور کلی منابع سفارشی را از طریق
[CRDs](#customresourcedefinitions)
مدیریت می‌کند.

لایه تجمیع اجازه می‌دهد تا شما بتوانید پیاده‌سازی‌های ویژه‌ای را برای منابع سفارشی خود فراهم کنید
با نوشتن و استقرار سرور API خود.
سرور API اصلی درخواست‌ها را به سرور API شما برای منابع سفارشی که شما مدیریت می‌کنید، انتقال می‌دهد
که این منابع را برای همه مشتریان خود در دسترس می‌سازد.

## انتخاب یک روش برای اضافه کردن منابع سفارشی

CRDs استفاده آسان‌تری دارند. API های تجمیعی انعطاف پذیرتر هستند. روشی را که بهترین نیازهای شما را برآورده می‌کند انتخاب کنید.

معمولاً CRDs مناسب هستند اگر:

* چندین فیلد دارید
* منبع را درون شرکت خود یا به عنوان بخشی از یک پروژه کوچک متن‌باز استفاده می‌کنید (برخلاف یک محصول تجاری)

### مقایسه آسانی استفاده

CRDs راحت‌تر برای ایجاد هستند نسبت به API های تجمیعی.

| CRDs                                | API های تجمیعی |
| ----------------------------------- | ---------------- |
| نیاز به برنامه‌نویسی ندارد. کاربران می‌توانند هر زبانی را برای یک کنترل کننده CRD انتخاب کنند. | نیاز به برنامه‌نویسی و ساخت باینری و تصویر دارد. |
| هیچ سرویس اضافی برای اجرا ندارد؛ CRDs توسط سرور API مدیریت می‌شوند. | یک سرویس اضافی برای ایجاد و ممکن است نیاز به انجام شود. |
| پشتیبانی مداوم بعد از ایجاد CRD ندارد. هر اصلاح اشکال به عنوان بخشی از ارتقاء‌های معمول Master Kubernetes دریافت می‌شود. | ممکن است نیاز به بازیابی دوره‌ای از رفع اشکالات از بالاترین سطح و بازسازی و به روز رسانی API های تجمیعی باشد. |
| نیازی به مدیریت نسخه‌های مختلف API شما ندارید؛ به عنوان مثال، زمانی که کنترل کننده مشتری برای این منبع را کنترل می‌کنید، می‌توانید آن را همگام با API ارتقا دهید. | نیاز به مدیریت نسخه‌های مختلف API شما دارید؛ به عنوان مثال، زمانی که یک افزونه را برای به اشتراک گذاشتن با جهان توسعه می‌دهید. |

### ویژگی‌های پیشرفته و انعطاف‌پذیری

API های تجمیعی ویژگی‌های پیشرفته‌تر API و سفارشی‌سازی ویژگی‌های دیگر را ارائه می‌دهند؛ به عنوان مثال، لایه ذخیره‌سازی.

| ویژگی | توضیحات | CRDs | API های تجمیعی |
| ------- | ----------- | ---- | -------------- |
| اعتبارسنجی | به کاربران کمک می‌کند تا اشتباهات را جلوگیری کنند و به شما امکان می‌دهد تا API خود را مستقل از مشتریان خود تکامل دهید. این ویژگی‌ها زمانی مفید است که مشتریان زیادی وجود داشته باشد که همه نمی‌توانند به یک زمان به‌روزرسانی کنند. | بله. بیشتر اعتبارسنجی می‌تواند در CRD با استفاده از [اعتبارسنجی OpenAPI v3.0](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation) مشخص شود. ویژگی CRDValidationRatcheting به شما اجازه می‌دهد که اعتبارسنجی‌هایی که با استفاده از OpenAPI شکست می‌خورند، را نادیده بگیرید اگر قسمت شکست داده شده از منبع تغییر نکرده باشد. هر اعتبارسنجی دیگری که توسط اضافه کردن یک [کروکوی ولیدیشن](/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9) پشتیبانی می‌شود. | بله، چک‌های اعتبارسنجی دلخواه |
| Defaulting | برای اطلاعات بالاتر نگاه کنید | بله، هر از طریق [اعتبارسنجی OpenAPI v3.0](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#defaulting) کلمه `default` (GA در 1.17)، یا از طریق یک [کروکوی میوتینگ](/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook) (اگرچه این عمل هنگام خواندن از etcd برای اشیاء قدیمی انجام نمی‌شود). | بله |
| چندین نسخه‌بندی | اجازه می‌دهد تا همان شیء را از طریق دو نسخه API خدمت کند. می‌تواند کمک کند تغییرات API مانند تغییر نام فیلد‌ها را آسان‌تر کند. کم اهمیت‌تر است اگر شما نسخه‌های مشتری خود را کنترل می‌کنید. | [بله](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning) | بله |
| ذخیره سازی سفارشی | اگر نیاز به ذخیره سازی با یک حالت عملکرد متفاوت (برای مثال، یک پایگاه داده مسلسل به جای ذخیره‌سازی کلید-مقدار) یا جداسازی برای امنیت (برای مثال، رمزگذاری اطلاعات حساس و غیره) دارید | نه | بله |
| منطق تجاری سفارشی | انجام بررسی‌ها یا اقدامات خود را در زمان ایجاد، خواندن، به‌روزرسانی یا حذف یک شیء | بله، با استفاده از [وب‌هوک](/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks) | بله |
| مقیاس زیر منبع | اجازه می‌دهد تا سیستم‌هایی مانند HorizontalPodAutoscaler و PodDisruptionBudget با منبع جدید خود تعامل کنند | [بله](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource) | بله |
| وضعیت زیر منبع | اجازه می‌دهد کنترل دسترسی دقیق‌تری که کاربر قسمت مشخصات را می‌نویسد و کنترل کننده بخش وضعیت را می‌نویسد. اجازه می‌دهد تا نسل شیء را برای اصلاح داده سفارشی منابع افزایش دهد (نیاز به بخش جداگانه از مشخصات و وضعیت در شیء منبع) | [بله](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource) | بله |
| سایر زیرمنابع | اضافه کردن عملیاتی غیر از CRUD، مانند "logs" یا "exec" | نه | بله |
| strategic-merge-patch | نقاط تماس جدید با پچ کردن با `Content-Type: application/strategic-merge-patch+json`. مفید برای به‌روزرسانی اشیاء که ممکن است به‌طور محلی و توسط سرور تغییر یابد. برای اطلاعات بیشتر، به ["Update API Objects in Place Using kubectl patch"](/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/) مراجعه کنید | نه | بله |
| Protocol Buffers | منبع جدید برای مشتریانی که می‌خواهند از بوفرهای پروتکل استفاده کنند | نه | بله |
| OpenAPI Schema | آیا یک اسکیما OpenAPI (swagger) برای انواعی که می‌تواند به طور پویا از سرور فراخوانی شود؟ آیا کاربر با اطمینان از نام‌های فیلدی می‌تواند به اطمینان برسد که فقط فیلد‌های مجاز تنظیم شده است؟ آیا انواع توسط آن تحمیل می‌شوند (به عبارت دیگر، عدد را در یک فیلد رشته قرار ندهید؟) | بله، بر اساس اسکیما [اعتبارسنجی OpenAPI v3.0](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation) (GA در 1.16). | بله |

### ویژگی‌های مشترک

زمانی که یک منبع سفارشی ایجاد می‌کنید، سایر CRD یا یک AA می‌توانید ویژگی‌های زیادی برای API خود دریافت کنید
نسبت به پیاده سازی آن در خارج از پلت فرم Kubernetes:

| ویژگی | عملکرد آن |
| ------- | ------------ |
| CRUD | نقاط تماس جدید CRUD عملیات اساسی را از طریق HTTP و `kubectl` پشتیبانی می‌کنند |
| Watch | نقاط تماس جدید پشتیبانی از عملیات Watch Kubernetes را از طریق HTTP پشتیبانی می‌کنند |
| Discovery | مشتریان مانند `kubectl` و داشبورد به طور خودکار ارائه‌دهنده عملیات لیست، نمایش و ویرایش فیلد را در منابع شما ارائه می‌دهند |
| json-patch | نقاط تماس جدید PATCH را با `Content-Type: application/json-patch+json` پشتیبانی می‌کنند |
| merge-patch | نقاط تماس جدید PATCH را با `Content-Type: application/merge-patch+json` پشتیبانی می‌کنند |
| HTTPS | نقاط تماس جدید HTTPS را استفاده می‌کنند |
| Built-in Authentication | دسترسی به افزونه از طریق سرور API اصلی (لایه تجمع) برای احراز هویت |
| Built-in Authorization | دسترسی به افزونه می‌تواند اجازه استفاده از احراز هویت استفاده شده توسط سرور API اصلی را دوباره استفاده کند؛ به عنوان مثال، RBAC. |
| Finalizers | حذف منابع توسعه‌یافته را تا زمانی که پاک‌سازی خارجی اتفاق می‌افتد مسدود می‌کند. |
| Admission Webhooks | ارزش پیش‌فرض تنظیمات و اعتبارسنجی منابع توسعه‌یافته را در هر عملیات create/update/delete. |
| UI/CLI Display | کنترل‌کننده، داشبورد می‌توانند منابع گسترش را نمایش دهند. |
| Unset versus Empty | مشتریان می‌توانند فیلدهای غیر تنظیم شده را از فیلدهای با ارزش صفر تشخیص دهند. |
| Client Libraries Generation | Kubernetes کتابخانه‌های مشتری جنریک را فراهم می‌کند، و همچنین ابزارهایی برای تولید کتابخانه‌های مشتری ویژه نوع. |
| Labels and annotations | متا داده‌های مشترک در سراسر ابزارهایی که می‌دانند که چگونه برای ویرایش برای منابع اصلی و منابع سفارشی ویرایش کنند. |

## آماده سازی برای نصب منبع سفارشی

قبل از اضافه کردن یک منبع سفارشی به خوشه خود، چند نکته وجود دارد که باید آگاه باشید.

### کد کد شخص ثالث و نقاط جدید خرابی

هنگامی که یک CRD ایجاد می‌کنید، خودبخود هیچ نقطه خرابی جدیدی اضافه نمی‌شود (به عنوان مثال، باعث اجرای یک کد شخص ثالث در سرور API شما می‌شود)، بسته‌ها (به عنوان مثال، چارت‌ها) یا بسته‌های نصب دیگر اغلب شامل CRD ها به همراه یک انتشار از کد شخص ثالث است که منطق تجاری را برای منبع سفارشی جدید پیاده‌سازی می‌کند.

نصب کردن یک سرور API آمیزشی همیشه شامل اجرای یک انتشار جدید است.

### ذخیره‌سازی

منابع سفارشی فضای ذخیره‌سازی را به همان شیوه‌ای که ConfigMaps انجام می‌دهد، مصرف می‌کنند. ایجاد زیادی منابع سفارشی ممکن است فضای ذخیره‌سازی سرور API خود را بارگذاری کند.

سرورهای API آمیزشی ممکن است از همان ذخیره‌سازی استفاده کنند که سرور API اصلی استفاده می‌کند، که در این صورت هشدار مشابهی اعمال می‌شود.

### احراز هویت، اجازه و بررسی

CRD ها همیشه از همان احراز هویت، اجازه و ثبت نظارتی استفاده می‌کنند که منابع درون ساخته شده API شما است.

اگر از RBAC برای اجازه استفاده می‌کنید، اکثر نقش‌های RBAC اجازه دسترسی به منابع جدید را (به جز نقش cluster-admin یا هر نقشی که با قوانین گسترده‌ای ایجاد شود) اعطا نمی‌کنند. شما باید به طور صریح دسترسی به منابع جدید را اعطا کنید. CRD ها و سرورهای API آمیزشی اغلب با تعاریف نقش جدید برای انواعی که اضافه می‌کنند، همراه هستند.

سرورهای API آمیزشی ممکن است از همان احراز هویت، اجازه و ثبت نظارتی استفاده کنند یا نکنند.

## دسترسی به منبع سفارشی

[کتابخانه‌های مشتری](/docs/reference/using-api/client-libraries/) Kubernetes می‌توانند برای دسترسی به منابع سفارشی استفاده شوند. همه کتابخانه‌های مشتری پشتیبانی از منابع سفارشی را ندارند. کتابخانه‌های Go و Python این پشتیبانی را دارند.

زمانی که یک منبع سفارشی را اضافه می‌کنید، می‌توانید از آن با استفاده از موارد زیر دسترسی پیدا کنید:

- `kubectl`
- کتابخانه مشتری پویا Kubernetes
- یک مشتری REST که خودتان می‌نویسید.
- یک مشتری تولید شده با [ابزار‌های تولید مشتری Kubernetes](https://github.com/kubernetes/code-generator) (تولید چنین مشتری پیچیده است، اما برخی پروژه‌ها ممکن است همراه با CRD یا AA یک مشتری را ارائه دهند).

## انتخاب‌گرهای فیلد منبع سفارشی

[انتخاب‌گرهای فیلد](/docs/concepts/overview/working-with-objects/field-selectors/) به کاربران امکان می‌دهند تا منابع سفارشی را بر اساس مقدار یک یا چند فیلد منبع انتخاب کنند.

تمام منابع سفارشی پشتیبانی از انتخاب‌گرهای فیلد `metadata.name` و `metadata.namespace` دارند.

فیلدهای اعلام شده در {{< glossary_tooltip term_id="CustomResourceDefinition" text="CustomResourceDefinition" >}} همچنین می‌توانند با انتخاب‌گرهای فیلد استفاده شوند زمانی که در فیلد `spec.versions[*].selectableFields` از {{< glossary_tooltip term_id="CustomResourceDefinition" text="CustomResourceDefinition" >}} قرار گیرند.

### فیلدهای قابل انتخاب برای منابع سفارشی {#crd-selectable-fields}

{{< feature-state feature_gate_name="CustomResourceFieldSelectors" >}}

برای استفاده از این رفتار، باید `CustomResourceFieldSelectors`
[feature gate](/docs/reference/command-line-tools-reference/feature-gates/) را فعال کنید که سپس بر روی تمام CustomResourceDefinitions در خوشه شما اعمال می‌شود.

فیلد `spec.versions[*].selectableFields` یک {{< glossary_tooltip term_id="CustomResourceDefinition" text="CustomResourceDefinition" >}} می‌تواند برای اعلام فیلدهای دیگری در منبع سفارشی استفاده شود که می‌توانند در انتخاب‌گرهای فیلد استفاده شوند. در زیر، مثالی از اضافه کردن فیلدهای `.spec.color` و `.spec.size` به عنوان فیلدهای قابل انتخاب آمده است.

{{% code_sample file="customresourcedefinition/shirt-resource-definition.yaml" %}}

سپس می‌توان از انتخاب‌گرهای فیلد برای گرفتن فقط منابع با `color` برابر با `blue` استفاده کرد:

```shell
kubectl get shirts.stable.example.com --field-selector spec.color=blue
```

خروجی باید به صورت زیر باشد:

```
NAME       COLOR  SIZE
example1   blue   S
example2   blue   M
```

## {{% heading "whatsnext" %}}

* یادگیری نحوه [گسترش API Kubernetes با لایه تجمیع](/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/).
* یادگیری نحوه [گسترش API Kubernetes با CustomResourceDefinition](/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/).