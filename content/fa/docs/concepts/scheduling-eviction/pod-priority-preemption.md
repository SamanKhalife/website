---
reviewers:
- davidopp
- wojtek-t
title: اولویت و پیش‌بینی Pod
content_type: مفهوم
weight: 90
---

<!-- overview -->

{{< feature-state for_k8s_version="v1.14" state="stable" >}}

[Pods](/docs/concepts/workloads/pods/) می‌توانند _اولویت_ داشته باشند. اولویت نشان‌دهنده اهمیت یک Pod نسبت به دیگر Pods است. اگر یک Pod نتواند زمانبندی شود، زمانبندی سعی می‌کند تا Pods با اولویت کمتر را پیش‌بینی (به زور حذف) کند تا زمانبندی Pod در انتظار امکان‌پذیر شود.


<!-- body -->


{{< warning >}}
در یک کلاستر که همه کاربران قابل اعتماد نیستند، کاربر مخرب می‌تواند Pods با بالاترین اولویت‌های ممکن را ایجاد کند که باعث حذف یا زمانبندی نشدن Pods دیگر می‌شود.
مدیر می‌تواند از ResourceQuota استفاده کند تا جلوگیری کند که کاربران Pods با اولویت‌های بالا ایجاد کنند.

برای جزئیات بیشتر به [limit Priority Class consumption by default](/docs/concepts/policy/resource-quotas/#limit-priority-class-consumption-by-default)
نگاه کنید.
{{< /warning >}}

## چگونگی استفاده از اولویت و پیش‌بینی

برای استفاده از اولویت و پیش‌بینی:

1.  یک یا چند [PriorityClasses](#priorityclass) اضافه کنید.

1.  Pods را با تنظیم [`priorityClassName`](#pod-priority) به یکی از PriorityClasses اضافه‌شده ایجاد کنید. البته نیازی نیست که به طور مستقیم Pods را ایجاد کنید؛ به طور معمول شما باید `priorityClassName` را به الگوی Pod در یک شیوه جمع‌آوری مانند Deployment اضافه کنید.

برای اطلاعات بیشتر درباره این مراحل ادامه بخوانید.

{{< note >}}
Kubernetes از پیش با دو PriorityClasses به نام‌های `system-cluster-critical` و `system-node-critical` همراه است.
این کلاس‌ها معمولی هستند و برای [تضمین اینکه اجزاء حیاتی همیشه اولویت بیشتری برای زمانبندی داشته باشند](/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/) استفاده می‌شوند.
{{< /note >}}

## PriorityClass

PriorityClass یک شیء بدون فضای نام است که یک نگاشت از نام کلاس اولویت به مقدار صحیح اولویت تعریف می‌کند. نام در فیلد `name` از فضای نام Metadata شی PriorityClass مشخص می‌شود. مقدار در فیلد مورد نیاز `value` مشخص می‌شود. هرچه مقدار بیشتر باشد، اولویت بیشتری خواهد داشت.
نام یک شیء PriorityClass باید یک [نام زیردامنه DNS معتبر](/docs/concepts/overview/working-with-objects/names#dns-subdomain-names) باشد و نمی‌تواند با `system-` پیش‌فرض شود.

یک شی PriorityClass می‌تواند هر مقدار صحیح 32-bit کمتر یا مساوی با 1 میلیارد داشته باشد. این به این معنی است که محدوده ارزش‌ها برای یک شی PriorityClass از -2147483648 تا 1000000000 شامل می‌شود. اعداد بزرگتر برای PriorityClasses داخلی نگهداری می‌شوند که اجزاء کریتیک سیستم را نشان می‌دهند. یک مدیر کلاستر باید یک شی PriorityClass را برای هر نگاشت مشابهی که می‌خواهند، ایجاد کنند.

PriorityClass دارای دو فیلد اختیاری نیز هست: `globalDefault` و `description`.
فیلد `globalDefault` نشان می‌دهد که مقدار این PriorityClass برای Pods بدون `priorityClassName` باید استفاده شود. تنها یک PriorityClass با `globalDefault` تنظیم شده به True می‌تواند در سیستم وجود داشته باشد. اگر هیچ PriorityClass با `globalDefault` تنظیم نشده باشد، اولویت Pods بدون `priorityClassName` صفر است.

فیلد `description` یک رشته دلخواه است. این برای اطلاع رسانی به کاربران کلاستر استفاده می‌شود که زمانی که باید از این PriorityClass استفاده کنند.

### نکات درباره PodPriority و کلاسترهای موجود

-   اگر یک کلاستر موجود را بدون این ویژگی ارتقا دهید، اولویت Pods موجود شما به طور موثر صفر است.

-   اضافه کردن یک PriorityClass با تنظیم `globalDefault` به True اولویت Pods موجود را تغییر نمی‌دهد. مقدار چنین PriorityClass فقط برای Pods ایجاد شده پس از اضافه شدن PriorityClass استفاده می‌شود.

-   اگر یک PriorityClass را حذف کنید، Pods موجودی که از نام PriorityClass حذف شده است استفاده می‌کنند باقی می‌مانند، اما شما نمی‌توانید Pods بیشتری ایجاد کنید که از نام PriorityClass حذف شده است.

### مثال PriorityClass

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: "این کلاس اولویت باید فقط برای Pods سرویس XYZ استفاده شود."
```

## PriorityClass غیر

-پیش‌بینی‌کننده {#non-preempting-priority-class}

{{< feature-state for_k8s_version="v1.24" state="stable" >}}

Pods با `preemptionPolicy: Never` در صف زمانبندی قرار می‌گیرند که با اولویت‌های پایین‌تر،
اما نمی‌توانند Pods دیگر را پیش‌بینی کنند.
یک Pod غیر-پیش‌بینی‌کننده که منتظر زمانبندی است، در صف زمانبندی باقی می‌ماند
تا منابع کافی آزاد شوند
و می‌تواند زمانبندی شود.
Pods غیر-پیش‌بینی‌کننده، مانند دیگر Pods،
مورد بررسی زمانبندی‌کننده قرار می‌گیرند.
این به این معنی است که اگر زمانبندی‌کننده این Pods را امتحان کرد و نتواند آنها را زمانبندی کند،
با فراوانی کمتری تکرار می‌شود
به سایر Pods با اولویت کم‌تر اجازه می‌دهد تا پیش از آنها زمانبندی شوند.

پیش‌بینی Pods غیر-پیش‌بینی‌کننده هنوز ممکن است توسط دیگر Pods با اولویت بالاتر انجام شود.

سیاست `preemptionPolicy` به پیش‌فرض `PreemptLowerPriority` تنظیم می‌شود،
که به Pods این PriorityClass اجازه می‌دهد تا Pods با اولویت پایین‌تر را پیش‌بینی کنند
(به عنوان رفتار پیش‌فرض موجود).
اگر `preemptionPolicy` به `Never` تنظیم شود،
Pods در این PriorityClass غیر-پیش‌بینی‌کننده خواهند بود.

یک مثال استفاده برای بارگذاری داده‌های علمی است.
کاربر می‌تواند یک کاری ارسال کند که می‌خواهد در اولویت بالاتر از سایر بارگذاری‌ها قرار گیرد،
اما نمی‌خواهد با حذف کارهای موجود از راه برنامه‌ریزی انجام شود.
کار بالاتر با اولویت با `preemptionPolicy: Never` پیش‌بینی خواهد شد
پیش از دیگر Pods در صف قرار گرفته است،
همان‌طور که منابع خوشبخت "طبیعی" برای آزاد شدن مجدد.

### مثال Non-preempting PriorityClass

```yaml
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority-nonpreempting
value: 1000000
preemptionPolicy: Never
globalDefault: false
description: "این کلاس اولویت باعث پیش‌بینی Pods دیگر نمی‌شود."
```

## اولویت Pod

پس از ایجاد یک یا چند PriorityClasses، می‌توانید Pods را ایجاد کنید که یکی از نام‌های این PriorityClasses را در مشخصات خود استفاده کنند. کنترل‌کننده ورود اولویت از فیلد `priorityClassName` استفاده می‌کند و مقدار صحیح اولویت را پر می‌کند. در صورت عدم یافتن کلاس اولویت، Pod رد می‌شود.

YAML زیر نمونه‌ای از پیکربندی Pod است که از PriorityClassی استفاده می‌کند که در مثال قبلی ایجاد شده است. کنترل‌کننده ورود اولویت مشخصات را بررسی می‌کند و اولویت Pod را به ۱۰۰۰۰۰۰ تعیین می‌کند.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    env: test
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
  priorityClassName: high-priority
```

### اثر اولویت Pod بر ترتیب زمان‌بندی

هنگامی که اولویت Pod فعال است، زمانبندی Pods در انتظار را بر اساس اولویت آن‌ها مرتب می‌کند و یک Pod در انتظار را جلوی دیگر Pods در انتظار با اولویت کمتر در صف زمانبندی قرار می‌دهد. به این ترتیب، اگر نیازهای زمانبندی آن را برآورده کند، Pod با اولویت بالاتر ممکن است زودتر از Pods با اولویت کمتر زمانبندی شود. اگر این‌گونه Pod نتواند زمانبندی شود، زمانبندی ادامه می‌دهد و سعی می‌کند Pods با اولویت کمتر دیگری را زمانبندی کند.

## پیش‌بینی

هنگامی که Pods ایجاد می‌شوند، به صف می‌روند و منتظر زمانبندی هستند. زمانبندی یک Pod را از صف برمی‌دارد و سعی می‌کند آن را در یک Node زمانبندی کند. اگر هیچ Node ای یافت نشود که همه نیازهای مشخص شده Pod را برآورده کند، منطق preemption برای Pod در انتظار فعال می‌شود. ما Pod در انتظار P را صدا می‌زنیم. منطق preemption سعی می‌کند یک Node را پیدا کند که حذف یک یا چند Pod با اولویت کمتر از P امکان دهد تا P بتواند بر روی آن Node زمانبندی شود. اگر چنین Node ای یافت شود، یک یا چند Pods با اولویت کمتر از Node خارج می‌شوند. پس از رفتن Pods، P می‌تواند بر روی Node زمانبندی شود.

### اطلاعات ارائه شده توسط کاربر

زمانی که Pod P یک یا چند Pod را بر روی Node N پیش‌بینی می‌کند، فیلد `nominatedNodeName` در وضعیت Pod P تنظیم می‌شود به نام Node N. این فیلد به زمانبندی کمک می‌کند تا منابع رزرو شده برای Pod P را پیگیری کند و همچنین اطلاعاتی درباره preemptions را به کاربران کلاستر ارائه می‌دهد.

لطفا توجه داشته باشید که Pod P به طور لزومی بر روی "نود منتخب" زمانبندی نمی‌شود. زمانبندی همیشه قبل از هر نود دیگری را امتحان می‌کند. پس از آن که Pods قربانی خود را خاتمه دهند یا خاتمه بدهند، زمانبندی سعی می‌کند تا Pods در صف انتظار را زمانبندی کند. بنابراین، معمولاً یک فاصله زمانی بین زمانی که زمانبندی Pods را preempts و زمانی که Pod P زمانبندی می‌شود وجود دارد. برای کمینه کردن این فاصله، می‌توان زمان پایان مهلت زندگی Pods با اولویت کمتر را صفر یا یک عدد کوچک تنظیم کرد.

#### محدودیت‌های preemption

##### زمانی که Pods دارای مدت زمان خاتمه مهلت ویکتیم هستند

هنگامی که Pods preempts می‌شوند، قربانیان مهلت خاتمه لطفاً
[period](/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination) را دریافت می‌کنند. آنها زمان دارند تا کار خود را انجام دهند و خروجی را دریافت کنند. اگر آنها اینکار را انجام ندهند، از بین می‌روند. این دوره خاتمه لطفاً فاصله‌ای بین نقطه‌ای که زمانبندی Pods preempts و زمانی که Pod P می‌تواند در Node N زمانبندی شود، ایجاد می‌کند.

 در این مدت، زمانبندی به سایر Pods در صف انتظار می‌پردازد. همانطور که قربانیان خروجی می‌کنند یا خاتمه می‌دهند، زمانبندی سعی می‌کند Pods در صف انتظار را زمانبندی کند. بنابراین، معمولاً یک فاصله زمانی بین نقطه‌ای که زمانبندی Pods را preempts و زمانی که Pod P زمانبندی می‌شود وجود دارد. به منظور کمینه کردن این فاصله، می‌توان زمان پایان مهلت زندگی Pods با اولویت کمتر را صفر یا یک عدد کوچک تنظیم کرد.

##### PodDisruptionBudget پشتیبانی می‌شود، اما تضمین نمی‌شود

[PDB](/docs/concepts/workloads/pods/disruptions/) یک بودجه تخلیه Pods است که به مالکان برنامه اجازه می‌دهد تا تعداد Pods یک برنامه تکراری که از اخلالات اختیاری ناشی از هم‌پیوندی‌ها توقف می‌کند، محدود کنند. Kubernetes پشتیبانی از PDB را هنگام preemption Pods، اما احترام PDB بهترین تلاش است. زمانبندی سعی می‌کند تا قربانیانی را پیدا کند که PDB آنها توسط preemption نقض نمی‌شود، اما اگر هیچ قربانی مناسبی پیدا نشود، preemption هنوز اتفاق می‌افتد و Pods با اولویت کمتر از حالت نادیده گرفته شده از PDB خود حذف می‌شوند.

##### پیوند دوستی از Pods با اولویت کمتر

Node فقط زمانی برای preemption مدنظر قرار می‌گیرد که جواب به این سوال مثبت است: "اگر همه Pods با اولویت کمتر از Pending Pod از Node حذف شوند، آیا می‌توان Pending Pod را بر روی Node زمانبندی کرد؟"

{{< note >}}
Preemption به طور لزومی تمام Pods با اولویت کمتر را حذف نمی‌کند. اگر Pending Pod بتواند با حذف کمتر از همه Pods با اولویت کمتر، فقط بخشی از Pods با اولویت کمتر حذف می‌شود. با این حال، پاسخ به سوال قبلی باید بله باشد. اگر پاسخ منفی باشد، Node برای preemption در نظر گرفته نمی‌شود.
{{< /note >}}

اگر یک Pending Pod دارای پیوند دوستی Pods با اولویت کمتر بر روی Node باشد، قاعده پیوند دوستی بین-Pod به یک یا چند Pod با اولویت کمتر بر روی Node را به ارمغان می‌آورد، قاعده پیوند دوستی بین-Pod را در این مورد برقرار نمی‌کند.
در این حالت، زمانبندی Pod ممکن نیست.

راه حل پیشنهادی ما برای این مشکل این است که فقط پیوند دوستی بین-Pod را نسبت به Pods با اولویت برابر یا بالاتر ایجاد کنید.
#### اختلاف نودهای زیر در برنامه

فرض کنید یک نود N برای preemption در نظر گرفته شده است تا بتواند یک Pod معلق P را بر روی N زمانبندی کند. این ممکن است به N گونه دیگر پرهزینه شود: Pod Q بر روی یک نود دیگر در همان منطقه با N اجرا می‌شود. Pod P دارای عدم دوستی موضوعی با Pod Q است (`topologyKey: topology.kubernetes.io/zone`). هیچ موارد دیگری از عدم دوستی بین Pod P و پاد در منطقه دیگر وجود ندارد. برای اینکه Pod P بر روی N زمانبندی شود، Pod Q را می‌توان preempted، اما زمانبندی cross-node انجام نمی‌دهد. بنابراین، Pod P به عنوان unschedulable بر روی N در نظر گرفته می‌شود.

اگر Pod Q از نود خود حذف شود، نقض عدم دوستی بین Pod از بین می‌رود و Pod P ممکن است بر روی N زمانبندی شود.

ما ممکن است در نسخه‌های آینده cross Node preemption را اضافه کنیم، اگر تقاضای کافی و یک الگوریتم با عملکرد منطقی پیدا کنیم.

## رفع اشکال

اولویت Pod و preemption ممکن است اثرات جانبی غیرقابل توجهی داشته باشد. در اینجا چند مثال از مشکلات محتمل و راه‌حل‌هایی برای مقابله با آن‌ها آورده شده است.

### Preemption غیرضروری Pods

Preemption باعث حذف Pods موجود از خوشه تحت فشار منابع می‌شود تا جایگزین برای Pods معلق با اولویت بالاتر شود. اگر به اشتباه اولویت‌های بالا را به برخی از Pods اختصاص دهید، این Pods با اولویت ناخودآگاه ممکن است باعث preemption در خوشه شود. اولویت Pod با تنظیم `priorityClassName` در مشخصات Pod مشخص می‌شود. مقدار عددی برای اولویت سپس حل و تکمیل به `priority` میدان `podSpec`.

برای رفع این مشکل، می‌توانید `priorityClassName` را برای استفاده از کلاس‌های اولویت پایین‌تر برای آن پاد تغییر دهید یا این فیلد را خالی بگذارید. یک `priorityClassName` خالی به طور پیش‌فرض به صفر حل می‌شود.

زمانی که یک Pod preempted شود، رویدادهایی برای Pod preempted ضبط می‌شود. Preemption فقط زمانی اتفاق می‌افتد که یک خوشه منابع کافی برای یک Pod ندارد. در این موارد، preemption فقط زمانی اتفاق می‌افتد که اولویت Pods معلق (preemptor) بالاتر از Pods قربانی باشد. Preemption نباید در مواردی اتفاق بیافتد که Pod معلق دیگری ندارد یا وقتی Pods معلق اولویت‌های مساوی یا پایین‌تر از قربانی‌ها دارند. اگر preemption در چنین حالت‌هایی اتفاق می‌افتد، لطفاً یک موضوع فایل کنید.

### Pods preempted، ولی preemptor زمانبندی نمی‌شود

هنگامی که Pods preempted می‌شود، آنها دوره خاتمه آرام کار خود را دریافت می‌کنند، که به طور پیش‌فرض ۳۰ ثانیه است. اگر Pods قربانی در این دوره خاتمه نیستند، آنها به طور اجباری پایان می‌یابند. هنگامی که همه قربانی‌ها بروند، Pod preemptor می‌تواند زمانبندی شود.

هنگامی که Pod preemptor منتظر قربانیان بروند، یک Pod با اولویت بالاتر ممکن است که در همان نود مناسب باشد. در این صورت، زمانبندی به جای preemptor Pod باید اولویت بالاتر باشد.

این رفتار مورد انتظار است: Pod با اولویت بالاتر باید جایگزین Pod با اولویت پایین‌تر باشد.

### Pods با اولویت بالاتر از Pods با اولویت کمتر preempted می‌شوند

زمانبندی سعی می‌کند تا نودها را پیدا کند که می‌تواند یک Pod معلق را اجرا کند. اگر یک نودی با Pods با اولویت پایین برای اجرا کردن Pod معلق مساعد نباشد، زمانبندی سعی می‌کند تا Pods با اولویت پایین تر از یک نود خود از خوشه اختار کند. اگر یک نود با Pods با اولویت پایین برای اجرا کردن Pod معلق مساعد نباشد، زمانبندی می‌تواند یک نود با Pods با اولویت بالاتر (مقایسه با Pods با اولویت دیگر) به preemption برنامه نویسد. قربانی‌ها همچنان باید اولویت پایین‌تر از Pods با preemptor Pods با اولویت بالاتر است.

هنگامی که برای preemption چندین نود وجود دارد، زمانبندی سعی می‌کند تا نود را با Pods با کمترین اولویت انتخاب کند. با این حال، اگر این Pods با PodDisruptionBudget که اگر بیش از می‌خواهد شکست باعث خواهد شد، زمانبندی می‌تواند یک نود با Pods با اولویت بالاتر را انتخاب کند.

## تعاملات بین اولویت Pod و کیفیت خدمات

اولویت Pod و کلاس QoS دو ویژگی ارگونال با تعداد اندک تعاملات و محدودیت‌های پیش‌فرض بر روی تنظیم اولویت Pod بر اساس کلاس QoS ندارند. منطق preemptive scheduler QoS را هنگام انتخاب اهداف preemption در نظر نمی‌گیرد. Preemption اولویت Pod را در نظر می‌گیرد و تلاش می‌کند یک مجموعه اهداف با کمترین اولویت انتخاب کند. Pods با اولویت بالاتر فقط برای preemption در نظر گرفته می‌شوند اگر حذف Pods با پایین‌ترین اولویت کافی نباشد تا زمانبندی preemptor Pod را امکان‌پذیر سازد یا اگر Pods با پایین‌ترین اولویت توسط PodDisruptionBudget محافظت شود.

kubelet از اولویت برای تعیین ترتیب pod برای تخلیه فشار از Node استفاده می‌کند. می‌توانید از کلاس QoS برای تخمین ترتیب استفاده کنید که احتمالاً جایگزین می‌شود توسط pods

موارد قابل تخلیه که بر اساس فاکتور های زیر ترتیب داده شده است:

1. آیا استفاده از منابع مصرف شده درخواست ها را تجاوز می کند
1. اولویت Pod
1. میزان مصرف منابع نسبت به درخواست

برای جزئیات بیشتر به [انتخاب Pods برای تخلیه توسط kubelet](/docs/concepts/scheduling-eviction/node-pressure-eviction/#pod-selection-for-kubelet-eviction) مراجعه کنید.

تخلیه فشار Node-pressure توسط kubelet Pods را تخلیه نمی‌کند وقتی استفاده از آنها از درخواست‌ها بیشتر نمی‌شود. اگر یک Pod با اولویت پایین درخواست‌های خود را تجاوز نکند، تخلیه نخواهد شد. یک Pod دیگر با اولویت بالاتر که از درخواست‌های خود بیشتر استفاده می‌کند ممکن است تخلیه شود.

## {{% heading "whatsnext" %}}

* درباره استفاده از ResourceQuotas در ارتباط با PriorityClasses بیشتر بخوانید: [محدودیت مصرف کلاس اولویت به صورت پیش‌فرض](/docs/concepts/policy/resource-quotas/#limit-priority-class-consumption-by-default)
* درباره [اختلالات Pod](/docs/concepts/workloads/pods/disruptions/) بیشتر بخوانید.
* درباره [اخراج API-نهاده](/docs/concepts/scheduling-eviction/api-eviction/) بیشتر بخوانید.
* درباره [اخراج فشار-Node](/docs/concepts/scheduling-eviction/node-pressure-eviction/) بیشتر بخوانید.
