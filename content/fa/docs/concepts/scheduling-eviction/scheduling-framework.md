---
reviewers:
- ahg-g
title: چارچوب برنامه‌ریزی
content_type: مفهوم
weight: 60
---

{{< feature-state for_k8s_version="v1.19" state="stable" >}}

_چارچوب برنامه‌ریزی_ یک معماری افزونه‌پذیر برای برنامه‌ریز Kubernetes است. این معماری شامل مجموعه‌ای از رابط‌های برنامه‌نویسی (APIs) است که به صورت مستقیم در برنامه‌ریز گنجانده شده‌اند. این رابط‌ها اجازه پذیرش بیشترین ویژگی‌های برنامه‌ریزی را به عنوان افزونه‌ها می‌دهند، در حالی که هسته برنامه‌ریزی را سبک و قابل نگهداری نگه می‌دارند. برای اطلاعات فنی بیشتر درباره طراحی این چارچوب به [پیشنهاد طراحی چارچوب برنامه‌ریزی][kep] مراجعه کنید.

[kep]: https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/624-scheduling-framework/README.md

## جریان کار چارچوب

چارچوب برنامه‌ریزی چندین نقطه توسعه را تعریف می‌کند. افزونه‌های برنامه‌ریز به یک یا چند نقطه توسعه می‌پیوندند. برخی از این افزونه‌ها می‌توانند تصمیمات برنامه‌ریزی را تغییر دهند و برخی فقط اطلاعاتی هستند.

هر تلاش برای برنامه‌ریزی یک پاد به دو فاز، چرخه برنامه‌ریزی و چرخه بایندینگ تقسیم می‌شود.

### چرخه برنامه‌ریزی و چرخه بایندینگ

چرخه برنامه‌ریزی یک گره برای پاد انتخاب می‌کند و چرخه بایندینگ این تصمیم را به خوشه اعمال می‌کند. با هم، یک چرخه برنامه‌ریزی و چرخه بایندینگ به عنوان یک "زمینه برنامه‌ریزی" شناخته می‌شوند.

چرخه‌های برنامه‌ریزی به صورت ترتیبی اجرا می‌شوند، در حالی که چرخه‌های بایندینگ ممکن است به صورت همزمان اجرا شوند.

### رابط‌ها

تصویر زیر مربوط به زمینه برنامه‌ریزی یک پاد و رابط‌هایی که چارچوب برنامه‌ریزی ارائه می‌دهد است.

یک افزونه ممکن است چندین رابط را برای انجام کارهای پیچیده‌تر یا دارای وضعیت دار اجرا کند.

![نقاط توسعه چارچوب برنامه‌ریزی](/images/docs/scheduling-framework-extensions.png)

### PreEnqueue {#pre-enqueue}

این افزونه‌ها قبل از اضافه کردن پادها به صف فعال داخلی فراخوانی می‌شوند، جایی که پادها به عنوان آماده برنامه‌ریزی علامت‌گذاری می‌شوند.

تنها زمانی که همه افزونه‌های PreEnqueue با `Success` بازگردانده شوند، پاد مجاز است به صف فعال وارد شود. در غیر این صورت، در لیست پادهای غیرقابل برنامه‌ریزی داخلی قرار می‌گیرد و شرایط `Unschedulable` نمی‌گیرد.

### EnqueueExtension

EnqueueExtension رابطی است که افزونه می‌تواند کنترل کند آیا باید برنامه‌ریزی پادهای رد شده توسط این افزونه را با تغییرات در خوشه تکرار کند. افزونه‌هایی که افزونه‌های PreEnqueue، PreFilter، Filter، Reserve یا Permit را پیاده‌سازی می‌کنند، باید این رابط را پیاده‌سازی کنند.

### QueueingHint

{{< feature-state for_k8s_version="v1.28" state="beta" >}}

QueueingHint یک تابع تماس برای تصمیم‌گیری است که آیا یک پاد می‌تواند به صف فعال یا صف به‌عقب بازنشانده شود. این تابع هر بار که یک نوع خاص از رویداد یا تغییر در خوشه رخ می‌دهد، اجرا می‌شود. وقتی QueueingHint متوجه می‌شود که رویداد ممکن است پاد را برای برنامه‌ریزی مناسب کند، پاد را در صف فعال یا صف به‌عقب قرار می‌دهد تا برنامه‌ریز پاد را دوباره امتحان کند.

{{< note >}}
ارزیابی QueueingHint در طول برنامه‌ریزی یک ویژگی سطح بتا است. سری انتشار v1.28 ابتدا دروازه ویژگی مرتبط را فعال کرد؛ با این حال، پس از کشف آثار حافظه بسیار زیاد، پروژه Kubernetes آن دروازه ویژگی را به صورت پیش‌فرض غیرفعال کرد. در Kubernetes {{< skew currentVersion >}}، این دروازه ویژگی غیرفعال است و شما باید آن را به صورت دستی فعال کنید.
می‌توانید این کار را از طریق ویژگی‌های دروازه `SchedulerQueueingHints` انجام دهید.
{{< /note >}}

### QueueSort {#queue-sort}

این افزونه‌ها برای مرتب‌سازی پادها در صف برنامه‌ریزی استفاده می‌شوند. یک افزونه مرتب‌سازی صف به طور اساسی یک تابع `Less(Pod1, Pod2)` ارائه می‌دهد. تنها یک افزونه مرتب‌سازی صف در هر زمان فعال می‌شود.

### PreFilter {#pre-filter}

این افزونه‌ها برای پیش‌پردازش اطلاعات در مورد پاد یا بررسی شرایط خاصی که خوشه یا پاد باید برآورده کنند، استفاده می‌شوند. اگر یک افزونه PreFilter خطا بازگرداند، چرخه برنامه‌ریزی متوقف می‌شود.

### Filter

این افزونه‌ها برای حذف گره‌هایی که نمی‌توانند پاد را اجرا کنند، استفاده می‌شوند. برای هر گره، برنامه‌ریز به ترتیب پلاگین‌های فیلتر را فراخوانی می‌کند. اگر هر یک از پلاگین‌های فیلتر گره را به عنوان غیرقابل انجام علامت‌گذاری کند، پلاگین‌های باقیمانده برای آن گره فراخوانی نخواهند شد. گره‌ها ممکن است به صورت همزمان ارزیابی شوند.

### PostFilter {#post-filter}

این افزونه‌ها پس از فاز فیلتر، اما فقط زمانی که برای پاد گره قابل انجامی یافت نشد، فراخوانی می‌شوند. افزونه‌ها به ترتیب پیکربندی شده خود فراخوانی می‌شوند. یک اجرای نمونه از پیاده‌سازی PostFilter، پیش‌اشغال، است که سعی می‌کند پاد را با تخریب دیگر پادها قابل اجرا کند.

### PreScore {#pre-score}

این افزونه‌ها برای انجام کارهای "پیش‌نمره‌گذاری" استفاده می‌شوند که یک وضعیت قابل اشتراک برای استفاده از پلاگین‌های امتیازدهی ایجاد می‌کنند. اگر یک افزونه PreScore خطا بازگرداند، چرخه برنامه‌ریزی متوقف می‌شود.

### Score {#scoring}

این افزونه‌ها برای رتبه‌بندی گره‌هایی که مراحل فیلترینگ را گذرانده‌اند، استفاده می‌شوند. برنامه‌ریز برای هر گره هر یک از پلاگین‌های امتیازدهی را فراخوانی خواهد کرد. یک محدوده واضح اعداد صحیح را نماینده حداقل و حداکثر امتیازها خواهد داشت. پس از مرحله تنظیم مجدد امتیازها، برنامه‌ریز گره‌های از تمام پلاگین‌ها به ترتیب وزن‌های پیکربندی شده امتیازهای گره را ترکیب می‌کند.

### NormalizeScore {#normalize-scoring}

این افزونه‌ها برای اصلاح امتیازها قبل از محاسبه‌ی نهایی ترتیب دهی گره‌ها توسط برنامه‌ریز استفاده می‌شوند. افزونه‌ای که برای این نقطه توسعه ثبت نام می‌کند، با نتایج [Score](#scoring) از همان افزونه فراخوانی می‌شود. این عمل یکبار در هر چرخه‌ی برنامه‌ریزی برای هر افزونه فراخوانی می‌شود.

به عنوان مثال، فرض کنید یک افزونه به نام `BlinkingLightScorer` گره‌ها را بر اساس تعداد چراغ‌های چشمک‌زن آن‌ها رتبه‌بندی می‌کند.

```go
func ScoreNode(_ *v1.pod, n *v1.Node) (int, error) {
    return getBlinkingLightCount(n)
}
```

با این حال، حداکثر تعداد چراغ‌های چشمک‌زن ممکن است به اندازه‌ی کوچکی نسبت به `NodeScoreMax` باشد. برای اصلاح این مسئله، `BlinkingLightScorer` باید همچنین برای این نقطه توسعه ثبت نام کند.

```go
func NormalizeScores(scores map[string]int) {
    highest := 0
    for _, score := range scores {
        highest = max(highest, score)
    }
    for node, score := range scores {
        scores[node] = score*NodeScoreMax/highest
    }
}
```

اگر هر افزونه NormalizeScore خطا بازگرداند، چرخه‌ی برنامه‌ریزی متوقف می‌شود.

{{< note >}}
افزونه‌هایی که می‌خواهند کار "پیش‌رزرو" را انجام دهند باید از نقطه توسعه NormalizeScore استفاده کنند.
{{< /note >}}

### Reserve {#reserve}

یک افزونه که رابط Reserve را پیاده‌سازی می‌کند دارای دو متد به نام‌های `Reserve` و `Unreserve` است که پشت سه فاز اطلاعاتی برنامه‌ریزی به نام Reserve و Unreserve قرار دارند. افزونه‌هایی که وضعیت اجرایی را حفظ می‌کنند (معمولاً "افزونه‌های قابلیت اجرایی" نامیده می‌شوند) باید از این فازها برای اطلاع رسانی به برنامه‌ریز در مورد انجام و عدم انجام منابع بر روی یک گره برای یک پاد خاص استفاده کنند.

فاز Reserve قبل از اینکه برنامه‌ریز واقعاً پاد را به گره مشخص خود متصل کند رخ می‌دهد. این فاز برای جلوگیری از شرایط رقابتی در حالی که برنامه‌ریز منتظر موفقیت بایند است وجود دارد. متد `Reserve` هر افزونه Reserve ممکن است موفق یا ناموفق باشد؛ اگر یک تماس متد `Reserve` ناموفق باشد، پلاگین‌های بعدی اجرا نمی‌شوند و فاز Reserve به عنوان ناموفق در نظر گرفته می‌شود. اگر متد `Reserve` همه افزونه‌ها موفق باشند، فاز Reserve به عنوان موفق در نظر گرفته می‌شود و بقیه‌ی چرخه برنامه‌ریزی و چرخه بایندینگ اجرا می‌شود.

فاز Unreserve در صورتی اجرا می‌شود که فاز Reserve یا یک فاز بعدی ناموفق باشد. در این حالت، متد `Unreserve` همه‌ی پلاگین‌های Reserve به ترتیب معکوس تماس متد `Reserve` اجرا خواهد شد. این فاز برای پاک‌سازی وضعیت مرتبط با پاد رزرو شده وجود دارد.

{{< caution >}}
پیاده‌سازی متد `Unreserve` در افزونه‌های Reserve باید idempotent باشد و نباید شکست داشته باشد.
{{< /caution >}}

### Permit

افزونه‌های Permit در انتهای چرخه برنامه‌ریزی برای هر پاد فراخوانی می‌شوند، به منظور جلوگیری یا تاخیر در اتصال به گره نامزد. یک افزونه Permit می‌تواند یکی از سه کار زیر را انجام دهد:

1. **تأیید** \
   زمانی که همه افزونه‌های Permit یک پاد را تأیید می‌کنند، به جهت اتصال ارسال می‌شود.

2. **رد** \
   اگر هر افزونه‌ی Permit یک پاد را رد کند، به صف برنامه‌ریزی برگردانده می‌شود. این اقدام باعث فراخوانی فاز Unreserve در [افزونه‌های Reserve](#reserve) می‌شود.

3. **انتظار** (با یک زمان انقضا) \
   اگر یک افزونه‌ی Permit "انتظار" بازگرداند، آنگاه پاد در یک لیست داخلی از "منتظر" نگهداری می‌شود و چرخه‌ی بایندینگ این پاد شروع می‌شود، اما به طور مستقیم مسدود شده تا تأیید شود. اگر یک زمان انقضا رخ دهد، **انتظار** به **رد** تبدیل می‌شود و پاد به صف برنامه‌ریزی برگردانده می‌شود و فاز Unreserve در [افزونه‌های Reserve](#reserve) را فعال می‌کند.

{{< note >}}
ه

ر افزونه‌ای می‌تواند به فهرست پادهای "منتظر" دسترسی داشته باشد و آن‌ها را تأیید کند
(مشاهده [`FrameworkHandle`](https://git.k8s.io/enhancements/keps/sig-scheduling/624-scheduling-framework#frameworkhandle))
ما انتظار داریم که فقط افزونه‌های Permit برای تأیید بایندینگ پادهای رزرو شده در حالت "منتظر" را تأیید کنند. یک باری که یک پاد تأیید شد، به [فاز PreBind](#pre-bind) ارسال می‌شود.
{{< /note >}}

### PreBind {#pre-bind}

این افزونه‌ها برای انجام هر کار مورد نیاز قبل از بایند کردن یک پاد استفاده می‌شوند. به عنوان مثال، یک افزونه PreBind ممکن است یک واحد شبکه را فراهم کند و آن را در گره مورد نظر قبل از اجازه دادن به پاد برای اجرا آنجا بمونت.

اگر هر افزونه PreBind خطا بازگرداند، پاد [رد](#reserve) می‌شود و به صف برنامه‌ریزی برگردانده می‌شود.

### Bind

این افزونه‌ها برای بایند کردن یک پاد به یک گره استفاده می‌شوند. افزونه‌های بایند فراخوانی نخواهند شد تا زمانی که تمام افزونه‌های PreBind کامل شده باشند. هر افزونه بایند به ترتیب پیکربندی شده فراخوانی می‌شود. یک افزونه بایند ممکن است تصمیم بگیرد که آیا یک پاد را پردازش کند یا نه. اگر یک افزونه بایند تصمیم دهد که یک پاد را پردازش کند، **افزونه‌های بایند باقی‌مانده صرفاً اجرا نمی‌شوند**.

### PostBind {#post-bind}

این رابط اطلاعاتی است. افزونه‌های PostBind پس از بایند کردن موفق یک پاد فراخوانی می‌شوند. این انتهای یک چرخه بایندینگ است و می‌تواند برای پاک‌سازی منابع مرتبط استفاده شود.

## API افزونه

دو گام به API افزونه وجود دارد. ابتدا افزونه‌ها باید ثبت و پیکربندی شوند، سپس از رابط‌های نقطه توسعه استفاده می‌کنند. رابط‌های نقطه توسعه به شکل زیر است.

```go
type Plugin interface {
    Name() string
}

type QueueSortPlugin interface {
    Plugin
    Less(*v1.pod, *v1.pod) bool
}

type PreFilterPlugin interface {
    Plugin
    PreFilter(context.Context, *framework.CycleState, *v1.pod) error
}

// ...
```

## پیکربندی افزونه

می‌توانید افزونه‌ها را در پیکربندی برنامه‌ریز فعال یا غیرفعال کنید. اگر از Kubernetes v1.18 به بعد استفاده می‌کنید، بیشتر افزونه‌های برنامه‌ریزی
[پیکربندی](/docs/reference/scheduling/config/#scheduling-plugins) وجود دارند و به طور پیش‌فرض فعال هستند.

علاوه بر افزونه‌های پیش‌فرض، می‌توانید افزونه‌های برنامه‌ریزی خود را پیاده‌سازی کنید و آن‌ها را به همراه افزونه‌های پیش‌فرض پیکربندی کنید. می‌توانید برای کسب اطلاعات بیشتر به
[scheduler-plugins](https://github.com/kubernetes-sigs/scheduler-plugins) مراجعه کنید.

اگر از Kubernetes v1.18 به بعد استفاده می‌کنید، می‌توانید مجموعه‌ای از افزونه‌ها را به عنوان یک پروفایل برنامه‌ریز پیکربندی کنید و سپس پروفایل‌های مختلف را برای متنوع‌سازی انواع بار کاری تعریف کنید.
جهت کسب اطلاعات بیشتر به [پروفایل‌های متعدد](/docs/reference/scheduling/config/#multiple-profiles) مراجعه کنید.
